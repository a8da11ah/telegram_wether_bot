This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.dockerignore
config.py
data_store.py
docker-compose.yml
Dockerfile
handlers/callback_handlers.py
handlers/command_handlers.py
localization.py
main.py
requirements.txt
utils.py
weather_api.py
weather_bot.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".dockerignore">
__pycache__/
*.pyc
*.pyo
*.pyd
.Python
.env.example
.git/
.gitignore
README.md
.pytest_cache/
.coverage
.vscode/
.idea/
</file>

<file path="config.py">
import os
from dotenv import load_dotenv

load_dotenv()

TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
WEATHER_API_KEY = os.getenv("WEATHER_API_KEY")

if not TELEGRAM_BOT_TOKEN or not WEATHER_API_KEY:
    raise ValueError("Missing required environment variables! Please set TELEGRAM_BOT_TOKEN and WEATHER_API_KEY in your .env file.")

# API URLs
WEATHER_API_URL = "https://api.openweathermap.org/data/2.5/weather"
FORECAST_API_URL = "https://api.openweathermap.org/data/2.5/forecast"
GEOCODING_API_URL = "https://api.openweathermap.org/geo/1.0/direct"

# Other configurations
DEFAULT_UNIT = "metric"
DEFAULT_LANGUAGE = "en"
MAX_FAVORITES = 10
MAX_COMPARE_CITIES = 4
REQUEST_TIMEOUT = 10
</file>

<file path="data_store.py">
import json
import logging
from typing import Dict, List
from dataclasses import dataclass, asdict

logger = logging.getLogger(__name__)

@dataclass
class UserPreferences:
    """User preferences data class"""
    unit: str = "metric"
    language: str = "en"
    favorites: List[str] = None
    default_city: str = None
    
    def __post_init__(self):
        if self.favorites is None:
            self.favorites = []

class UserDataStore:
    def __init__(self, filename: str = 'user_preferences.json'):
        self.filename = filename
        self.user_preferences: Dict[int, UserPreferences] = {}
        self.load_user_data()

    def load_user_data(self):
        """Load user preferences from file."""
        try:
            if os.path.exists(self.filename):
                with open(self.filename, 'r') as f:
                    data = json.load(f)
                    for user_id, prefs_data in data.items():
                        # Ensure favorites is a list if it was null/None in JSON
                        if 'favorites' in prefs_data and prefs_data['favorites'] is None:
                            prefs_data['favorites'] = []
                        self.user_preferences[int(user_id)] = UserPreferences(**prefs_data)
            logger.info(f"Loaded preferences for {len(self.user_preferences)} users.")
        except Exception as e:
            logger.error(f"Error loading user data from {self.filename}: {e}")

    def save_user_data(self):
        """Save user preferences to file."""
        try:
            data_to_save = {str(user_id): asdict(prefs) for user_id, prefs in self.user_preferences.items()}
            with open(self.filename, 'w') as f:
                json.dump(data_to_save, f, indent=2)
            logger.info(f"Saved preferences for {len(self.user_preferences)} users.")
        except Exception as e:
            logger.error(f"Error saving user data to {self.filename}: {e}")

    def get_user_prefs(self, user_id: int) -> UserPreferences:
        """Get user preferences or create default if not exists."""
        if user_id not in self.user_preferences:
            self.user_preferences[user_id] = UserPreferences()
            self.save_user_data() # Save new user's default prefs immediately
        return self.user_preferences[user_id]

    def reset_user_prefs(self, user_id: int):
        """Resets user preferences to default."""
        self.user_preferences[user_id] = UserPreferences()
        self.save_user_data()
</file>

<file path="handlers/callback_handlers.py">
import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes
from data_store import UserDataStore
from localization import get_localized_message
from handlers.command_handlers import send_current_weather, settings_command # Import settings_command to reuse it
from config import MAX_FAVORITES # Also need to access MAX_FAVORITES here

logger = logging.getLogger(__name__)

async def handle_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle inline keyboard callbacks."""
    query = update.callback_query
    await query.answer() # Acknowledge the callback query
    
    data = query.data
    user_id = update.effective_user.id
    user_data_store: UserDataStore = context.bot_data['user_data_store']
    weather_api_client = context.bot_data['weather_api_client']
    prefs = user_data_store.get_user_prefs(user_id)
    
    if data.startswith("weather_"):
        city = data.replace("weather_", "")
        await send_current_weather(update, city, prefs, weather_api_client, edit_message=True)
    
    elif data.startswith("addfav_"):
        city = data.replace("addfav_", "")
        if city.lower() not in [fav.lower() for fav in prefs.favorites]:
            prefs.favorites.append(city)
            user_data_store.save_user_data()
            await query.edit_message_text(get_localized_message(prefs.language, "added_favorite", city=city))
        else:
            await query.edit_message_text(get_localized_message(prefs.language, "already_favorite", city=city))
        # Optionally, refresh the message or go back to main menu

    elif data == "toggle_units":
        prefs.unit = "imperial" if prefs.unit == "metric" else "metric"
        user_data_store.save_user_data()
        await settings_command(update, context) # Re-send settings menu with updated unit
    
    elif data == "choose_language":
        keyboard = [
            [InlineKeyboardButton(get_localized_message(prefs.language, "english"), callback_data="set_lang_en")],
            [InlineKeyboardButton(get_localized_message(prefs.language, "arabic"), callback_data="set_lang_ar")],
            [InlineKeyboardButton(get_localized_message(prefs.language, "manage_favorites_back"), callback_data="back_to_settings")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(
            get_localized_message(prefs.language, "choose_language"),
            parse_mode='HTML',
            reply_markup=reply_markup
        )
    
    elif data.startswith("set_lang_"):
        lang_code = data.replace("set_lang_", "")
        prefs.language = lang_code
        user_data_store.save_user_data()
        language_name = get_localized_message(prefs.language, lang_code)
        await query.edit_message_text(get_localized_message(prefs.language, "language_set", language_name=language_name))
        await settings_command(update, context) # Go back to main settings menu
        
    elif data == "set_default_city":
        await query.edit_message_text(
            get_localized_message(prefs.language, "set_default_city_instructions"),
            parse_mode='HTML'
        )
    
    elif data == "manage_favorites":
        if not prefs.favorites:
            await query.edit_message_text(
                get_localized_message(prefs.language, "no_favorites"),
                parse_mode='HTML'
            )
            return
        
        keyboard = []
        for city in prefs.favorites:
            keyboard.append([InlineKeyboardButton(f"ğŸ—‘ï¸ Remove {city}", callback_data=f"removefav_callback_{city}")])
        
        keyboard.append([InlineKeyboardButton(get_localized_message(prefs.language, "manage_favorites_back"), callback_data="back_to_settings")])
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(
            get_localized_message(prefs.language, "manage_favorites_menu"),
            parse_mode='HTML',
            reply_markup=reply_markup
        )
    
    elif data.startswith("removefav_callback_"):
        city = data.replace("removefav_callback_", "")
        if city in prefs.favorites:
            prefs.favorites.remove(city)
            user_data_store.save_user_data()
            await query.edit_message_text(get_localized_message(prefs.language, "removed_favorite", city=city))
            await handle_callback(update, context) # Refresh the manage favorites list
        else:
            await query.edit_message_text(get_localized_message(prefs.language, "not_in_favorites", city=city))
    
    elif data == "back_to_settings":
        await settings_command(update, context)
    
    elif data == "reset_settings":
        user_data_store.reset_user_prefs(user_id)
        await query.edit_message_text(get_localized_message(prefs.language, "reset_settings_confirm"))
    
    # Handle help menu callbacks (from /start)
    elif data.startswith("help_"):
        help_type = data.replace("help_", "")
        # For simplicity, these just send a generic help message.
        # You could expand this to send specific help for each section.
        await query.edit_message_text(get_localized_message(prefs.language, "help"), parse_mode='HTML')
</file>

<file path="handlers/command_handlers.py">
import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes
from data_store import UserDataStore, UserPreferences
from localization import get_localized_message
from weather_api import WeatherAPI
from utils import format_weather_message, format_forecast_message, get_weather_emoji
from config import MAX_FAVORITES, MAX_COMPARE_CITIES

logger = logging.getLogger(__name__)

async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle /start command."""
    user_id = update.effective_user.id
    user_data_store: UserDataStore = context.bot_data['user_data_store']
    prefs = user_data_store.get_user_prefs(user_id)
    
    keyboard = [
        [InlineKeyboardButton(get_localized_message(prefs.language, "current_weather_button"), callback_data="help_weather")],
        [InlineKeyboardButton(get_localized_message(prefs.language, "five_day_forecast_button"), callback_data="help_forecast")],
        [InlineKeyboardButton(get_localized_message(prefs.language, "search_cities_button"), callback_data="help_search")],
        [InlineKeyboardButton(get_localized_message(prefs.language, "favorites_button"), callback_data="help_favorites")],
        [InlineKeyboardButton(get_localized_message(prefs.language, "settings_button"), callback_data="help_settings")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    welcome_message = get_localized_message(prefs.language, "welcome")
    await update.message.reply_text(welcome_message, parse_mode='HTML', reply_markup=reply_markup)

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle /help command."""
    user_id = update.effective_user.id
    user_data_store: UserDataStore = context.bot_data['user_data_store']
    prefs = user_data_store.get_user_prefs(user_id)
    help_message = get_localized_message(prefs.language, "help")
    await update.message.reply_text(help_message, parse_mode='HTML')

async def weather_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle /weather command."""
    user_id = update.effective_user.id
    user_data_store: UserDataStore = context.bot_data['user_data_store']
    weather_api_client: WeatherAPI = context.bot_data['weather_api_client']
    prefs = user_data_store.get_user_prefs(user_id)
    
    city = None
    if context.args:
        city = " ".join(context.args)
    elif prefs.default_city:
        city = prefs.default_city
    
    if not city:
        await update.message.reply_text(get_localized_message(prefs.language, "specify_city_weather"), parse_mode='HTML')
        return

    await send_current_weather(update, city, prefs, weather_api_client)

async def forecast_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle /forecast command."""
    user_id = update.effective_user.id
    user_data_store: UserDataStore = context.bot_data['user_data_store']
    weather_api_client: WeatherAPI = context.bot_data['weather_api_client']
    prefs = user_data_store.get_user_prefs(user_id)
    
    city = None
    if context.args:
        city = " ".join(context.args)
    elif prefs.default_city:
        city = prefs.default_city
    
    if not city:
        await update.message.reply_text(get_localized_message(prefs.language, "specify_city_forecast"), parse_mode='HTML')
        return
    
    await send_five_day_forecast(update, city, prefs, weather_api_client)

async def search_cities(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Search for cities."""
    user_id = update.effective_user.id
    user_data_store: UserDataStore = context.bot_data['user_data_store']
    weather_api_client: WeatherAPI = context.bot_data['weather_api_client']
    prefs = user_data_store.get_user_prefs(user_id)

    if not context.args:
        await update.message.reply_text(get_localized_message(prefs.language, "specify_query_search"), parse_mode='HTML')
        return
    
    query = " ".join(context.args)
    await update.message.reply_chat_action(action="typing")
    
    city_data = await weather_api_client.get_city_coordinates(query)
    
    if not city_data:
        await update.message.reply_text(get_localized_message(prefs.language, "error_searching_cities"))
        return
    
    if not city_data:
        await update.message.reply_text(get_localized_message(prefs.language, "no_cities_found_search", query=query))
        return
    
    keyboard = []
    city_list_str = ""
    
    for i, city_info in enumerate(city_data[:8], 1): # Limit to 8 results
        name = city_info['name']
        country = city_info.get('country', '')
        state = city_info.get('state', '')
        
        full_name = f"{name}, {country}"
        if state and state != name:
            full_name = f"{name}, {state}, {country}"
        
        city_list_str += f"{i}. {full_name}\n"
        keyboard.append([InlineKeyboardButton(f"ğŸŒ¤ï¸ {full_name}", callback_data=f"weather_{name}")])
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    message = get_localized_message(prefs.language, "cities_matching_search", query=query, city_list=city_list_str)
    await update.message.reply_text(message, parse_mode='HTML', reply_markup=reply_markup)

async def favorites_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Show favorite cities."""
    user_id = update.effective_user.id
    user_data_store: UserDataStore = context.bot_data['user_data_store']
    prefs = user_data_store.get_user_prefs(user_id)
    
    if not prefs.favorites:
        await update.message.reply_text(get_localized_message(prefs.language, "no_favorites"), parse_mode='HTML')
        return
    
    keyboard = []
    for city in prefs.favorites[:MAX_FAVORITES]:
        keyboard.append([InlineKeyboardButton(f"ğŸŒ¤ï¸ {city}", callback_data=f"weather_{city}")])
    
    keyboard.append([InlineKeyboardButton(get_localized_message(prefs.language, "manage_favorites_button"), callback_data="manage_favorites")])
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    message = get_localized_message(prefs.language, "favorites_list", count=len(prefs.favorites))
    await update.message.reply_text(message, parse_mode='HTML', reply_markup=reply_markup)

async def add_favorite(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Add city to favorites."""
    user_id = update.effective_user.id
    user_data_store: UserDataStore = context.bot_data['user_data_store']
    weather_api_client: WeatherAPI = context.bot_data['weather_api_client']
    prefs = user_data_store.get_user_prefs(user_id)

    if not context.args:
        await update.message.reply_text(get_localized_message(prefs.language, "specify_city_addfav"), parse_mode='HTML')
        return
    
    city = " ".join(context.args)
    
    if not await weather_api_client.verify_city_exists(city, prefs.language):
        await update.message.reply_text(get_localized_message(prefs.language, "city_not_found", city=city))
        return
    
    if city.lower() not in [fav.lower() for fav in prefs.favorites]:
        prefs.favorites.append(city)
        user_data_store.save_user_data()
        await update.message.reply_text(get_localized_message(prefs.language, "added_favorite", city=city))
    else:
        await update.message.reply_text(get_localized_message(prefs.language, "already_favorite", city=city))

async def remove_favorite(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Remove city from favorites."""
    user_id = update.effective_user.id
    user_data_store: UserDataStore = context.bot_data['user_data_store']
    prefs = user_data_store.get_user_prefs(user_id)

    if not context.args:
        await update.message.reply_text(get_localized_message(prefs.language, "specify_city_removefav"), parse_mode='HTML')
        return
    
    city_to_remove = " ".join(context.args)
    
    found = False
    for fav in prefs.favorites[:]: # Iterate over a copy
        if fav.lower() == city_to_remove.lower():
            prefs.favorites.remove(fav)
            user_data_store.save_user_data()
            await update.message.reply_text(get_localized_message(prefs.language, "removed_favorite", city=fav))
            found = True
            break
    
    if not found:
        await update.message.reply_text(get_localized_message(prefs.language, "not_in_favorites", city=city_to_remove))

async def settings_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Show settings menu."""
    user_id = update.effective_user.id
    user_data_store: UserDataStore = context.bot_data['user_data_store']
    prefs = user_data_store.get_user_prefs(user_id)
    
    unit_name = get_localized_message(prefs.language, "units_celsius") if prefs.unit == "metric" else get_localized_message(prefs.language, "units_fahrenheit")
    language_name = get_localized_message(prefs.language, prefs.language)
    default_city_name = prefs.default_city or get_localized_message(prefs.language, "default_city_not_set")

    keyboard = [
        [InlineKeyboardButton(get_localized_message(prefs.language, "units_toggle_button", unit_name=unit_name), callback_data="toggle_units")],
        [InlineKeyboardButton(get_localized_message(prefs.language, "language_toggle_button", language_name=language_name), callback_data="choose_language")],
        [InlineKeyboardButton(get_localized_message(prefs.language, "default_city_button", city_name=default_city_name), callback_data="set_default_city")],
        [InlineKeyboardButton(get_localized_message(prefs.language, "manage_favorites_button"), callback_data="manage_favorites")],
        [InlineKeyboardButton(get_localized_message(prefs.language, "reset_settings_button"), callback_data="reset_settings")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    message = get_localized_message(
        prefs.language, 
        "settings_menu", 
        unit=unit_name, 
        language=language_name, 
        default_city=default_city_name, 
        fav_count=len(prefs.favorites)
    )
    if update.callback_query: # If triggered by a callback, edit message
        await update.callback_query.edit_message_text(message, parse_mode='HTML', reply_markup=reply_markup)
    else: # If triggered by command
        await update.message.reply_text(message, parse_mode='HTML', reply_markup=reply_markup)

async def weather_alerts(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Show weather alerts for a city."""
    user_id = update.effective_user.id
    user_data_store: UserDataStore = context.bot_data['user_data_store']
    weather_api_client: WeatherAPI = context.bot_data['weather_api_client']
    prefs = user_data_store.get_user_prefs(user_id)
    
    city = None
    if context.args:
        city = " ".join(context.args)
    elif prefs.default_city:
        city = prefs.default_city
    
    if not city:
        await update.message.reply_text(get_localized_message(prefs.language, "specify_city_alerts"), parse_mode='HTML')
        return
    
    await update.message.reply_chat_action(action="typing")
    weather_data = await weather_api_client.get_current_weather(city, prefs.unit, prefs.language)

    if not weather_data:
        if weather_data and weather_data.get("error") == "city_not_found":
            await update.message.reply_text(get_localized_message(prefs.language, "city_not_found", city=city))
        else:
            await update.message.reply_text(get_localized_message(prefs.language, "error_fetching_alerts"))
        return
    
    alerts = []
    
    temp = weather_data['main']['temp']
    humidity = weather_data['main']['humidity']
    wind_speed = weather_data.get('wind', {}).get('speed', 0)
    weather_id = weather_data['weather'][0]['id']
    
    if prefs.unit == 'metric':
        if temp > 35:
            alerts.append(get_localized_message(prefs.language, "extreme_heat_warning"))
        elif temp < -10:
            alerts.append(get_localized_message(prefs.language, "extreme_cold_warning"))
        if wind_speed > 10:
            alerts.append(get_localized_message(prefs.language, "high_wind_alert"))
    else: # imperial
        if temp > 95:
            alerts.append(get_localized_message(prefs.language, "extreme_heat_warning"))
        elif temp < 14:
            alerts.append(get_localized_message(prefs.language, "extreme_cold_warning"))
        if wind_speed > 22:
            alerts.append(get_localized_message(prefs.language, "high_wind_alert"))
    
    if humidity > 85:
        alerts.append(get_localized_message(prefs.language, "high_humidity_alert"))
    
    if weather_id < 300:
        alerts.append(get_localized_message(prefs.language, "thunderstorm_alert"))
    elif weather_id < 600 and weather_id >= 500:
        alerts.append(get_localized_message(prefs.language, "heavy_rain_alert"))
    elif weather_id < 700 and weather_id >= 600:
        alerts.append(get_localized_message(prefs.language, "snow_alert"))
    
    city_name = f"{weather_data['name']}, {weather_data['sys']['country']}"
    
    if alerts:
        alerts_list_str = "\n".join(f"â€¢ {alert}" for alert in alerts)
        message = get_localized_message(prefs.language, "alerts_for_city", city=city_name, alerts_list=alerts_list_str, temp=f"{temp}Â°{'C' if prefs.unit == 'metric' else 'F'}")
    else:
        message = get_localized_message(prefs.language, "no_alerts", city=city_name)
    
    await update.message.reply_text(message, parse_mode='HTML')

async def compare_cities(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Compare weather between cities."""
    user_id = update.effective_user.id
    user_data_store: UserDataStore = context.bot_data['user_data_store']
    weather_api_client: WeatherAPI = context.bot_data['weather_api_client']
    prefs = user_data_store.get_user_prefs(user_id)

    if not context.args:
        await update.message.reply_text(get_localized_message(prefs.language, "specify_cities_compare"), parse_mode='HTML')
        return
    
    cities_input = " ".join(context.args)
    cities = [city.strip() for city in cities_input.split(',')]
    
    if len(cities) < 2:
        await update.message.reply_text(get_localized_message(prefs.language, "not_enough_cities"), parse_mode='HTML')
        return
    
    if len(cities) > MAX_COMPARE_CITIES:
        await update.message.reply_text(get_localized_message(prefs.language, "too_many_cities"))
        cities = cities[:MAX_COMPARE_CITIES]
    
    await update.message.reply_chat_action(action="typing")
    
    weather_data_list = []
    for city in cities:
        data = await weather_api_client.get_current_weather(city, prefs.unit, prefs.language)
        if data and not data.get("error"):
            weather_data_list.append(data)
        else:
            await update.message.reply_text(get_localized_message(prefs.language, "city_not_found", city=city))
            return # Stop comparison if any city is not found
    
    if not weather_data_list:
        await update.message.reply_text(get_localized_message(prefs.language, "error_fetching_data_any_cities"))
        return
    
    unit_symbol = "Â°C" if prefs.unit == "metric" else "Â°F"
    
    message = get_localized_message(prefs.language, "weather_comparison_title")
    
    # Temperature comparison
    temps = [(data['name'], data['main']['temp']) for data in weather_data_list]
    temps.sort(key=lambda x: x[1], reverse=True)
    
    message += get_localized_message(prefs.language, "temperature_comparison", unit_symbol=unit_symbol)
    for i, (name, temp) in enumerate(temps, 1):
        emoji = "ğŸ”¥" if i == 1 else "ğŸ§Š" if i == len(temps) else "ğŸŒ¡ï¸"
        message += f"{i}. {emoji} {name}: {temp:.1f}{unit_symbol}\n"
    
    message += "\n"
    
    # Humidity comparison
    humidities = [(data['name'], data['main']['humidity']) for data in weather_data_list]
    humidities.sort(key=lambda x: x[1], reverse=True)
    
    message += get_localized_message(prefs.language, "humidity_comparison")
    for i, (name, humidity) in enumerate(humidities, 1):
        emoji = "ğŸ’§" if i == 1 else "ğŸœï¸" if i == len(humidities) else "ğŸ’¨"
        message += f"{i}. {emoji} {name}: {humidity}%\n"
    
    message += "\n"
    
    # Weather conditions
    message += get_localized_message(prefs.language, "current_conditions_comparison")
    for data_item in weather_data_list:
        name = data_item['name']
        condition = data_item['weather'][0]['description'].title()
        emoji = get_weather_emoji(data_item['weather'][0]['id'])
        message += f"{emoji} {name}: {condition}\n"
    
    # Find extremes
    message += get_localized_message(prefs.language, "highlights_comparison")
    hottest = max(weather_data_list, key=lambda x: x['main']['temp'])
    coldest = min(weather_data_list, key=lambda x: x['main']['temp'])
    most_humid = max(weather_data_list, key=lambda x: x['main']['humidity'])
    
    message += get_localized_message(prefs.language, "hottest", city=hottest['name'], temp=hottest['main']['temp'], unit_symbol=unit_symbol) + "\n"
    message += get_localized_message(prefs.language, "coldest", city=coldest['name'], temp=coldest['main']['temp'], unit_symbol=unit_symbol) + "\n"
    message += get_localized_message(prefs.language, "most_humid", city=most_humid['name'], humidity=most_humid['main']['humidity'])
    
    await update.message.reply_text(message, parse_mode='HTML')

async def weather_map(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Provide weather map link."""
    user_id = update.effective_user.id
    user_data_store: UserDataStore = context.bot_data['user_data_store']
    weather_api_client: WeatherAPI = context.bot_data['weather_api_client']
    prefs = user_data_store.get_user_prefs(user_id)

    if not context.args:
        await update.message.reply_text(get_localized_message(prefs.language, "specify_city_map"), parse_mode='HTML')
        return
    
    city = " ".join(context.args)
    
    await update.message.reply_chat_action(action="typing")
    geo_data = await weather_api_client.get_city_coordinates(city)
    
    if not geo_data:
        await update.message.reply_text(get_localized_message(prefs.language, "error_generating_map"))
        return
    
    if not geo_data:
        await update.message.reply_text(get_localized_message(prefs.language, "city_not_found", city=city))
        return
    
    lat = geo_data[0]['lat']
    lon = geo_data[0]['lon']
    name = geo_data[0]['name']
    country = geo_data[0].get('country', '')
    
    openweather_map = f"https://openweathermap.org/weathermap?basemap=map&cities=true&layer=temperature&lat={lat}&lon={lon}&zoom=10"
    Maps = f"https://www.google.com/maps/@{lat},{lon},10z"
    
    keyboard = [
        [InlineKeyboardButton(get_localized_message(prefs.language, "openweather_map_button"), url=openweather_map)],
        [InlineKeyboardButton(get_localized_message(prefs.language, "Maps_button"), url=Maps)]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    message = get_localized_message(prefs.language, "map_links", city=f"{name}, {country}")
    await update.message.reply_text(message, parse_mode='HTML', reply_markup=reply_markup)

async def handle_city_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle direct city name messages (non-command)."""
    city = update.message.text.strip().strip('"\'')
    user_id = update.effective_user.id
    user_data_store: UserDataStore = context.bot_data['user_data_store']
    weather_api_client: WeatherAPI = context.bot_data['weather_api_client']
    prefs = user_data_store.get_user_prefs(user_id)
    
    # Auto-add frequently searched cities to favorites
    if city.lower() not in [fav.lower() for fav in prefs.favorites] and len(prefs.favorites) < MAX_FAVORITES:
        if await weather_api_client.verify_city_exists(city, prefs.language):
            keyboard = [[InlineKeyboardButton(get_localized_message(prefs.language, "add_to_favorites_button"), callback_data=f"addfav_{city}")]]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await send_current_weather(update, city, prefs, weather_api_client, suggest_favorite=reply_markup)
        else:
            await send_current_weather(update, city, prefs, weather_api_client)
    else:
        await send_current_weather(update, city, prefs, weather_api_client)

# Helper functions that interact with API and send messages
async def send_current_weather(update: Update, city: str, prefs: UserPreferences, weather_api_client: WeatherAPI, edit_message: bool = False, suggest_favorite=None):
    """Fetches and sends current weather data."""
    if not edit_message:
        await update.message.reply_chat_action(action="typing")
    
    weather_data = await weather_api_client.get_current_weather(city, prefs.unit, prefs.language)

    if not weather_data:
        message = get_localized_message(prefs.language, "api_request_failed")
        if weather_data and weather_data.get("error") == "city_not_found":
            message = get_localized_message(prefs.language, "city_not_found_weather", city=city)
        
        if edit_message:
            await update.callback_query.edit_message_text(message)
        else:
            await update.message.reply_text(message)
        return

    weather_message = format_weather_message(weather_data, prefs.language, prefs.unit)
    
    if edit_message:
        await update.callback_query.edit_message_text(weather_message, parse_mode='HTML')
    else:
        await update.message.reply_text(weather_message, parse_mode='HTML', reply_markup=suggest_favorite)

async def send_five_day_forecast(update: Update, city: str, prefs: UserPreferences, weather_api_client: WeatherAPI):
    """Fetches and sends 5-day weather forecast."""
    await update.message.reply_chat_action(action="typing")
    
    forecast_data = await weather_api_client.get_five_day_forecast(city, prefs.unit, prefs.language)

    if not forecast_data:
        message = get_localized_message(prefs.language, "error_fetching_forecast")
        if forecast_data and forecast_data.get("error") == "city_not_found":
            message = get_localized_message(prefs.language, "city_not_found", city=city)
        
        await update.message.reply_text(message)
        return

    forecast_message = format_forecast_message(forecast_data, prefs.language, prefs.unit)
    await update.message.reply_text(forecast_message, parse_mode='HTML')
</file>

<file path="localization.py">
MESSAGES = {
    "en": {
        "welcome": "ğŸŒ¤ï¸ <b>Welcome to Advanced Weather Bot!</b> ğŸŒ¤ï¸\n\nI'm your comprehensive weather assistant with many features:\n\nğŸ”¹ Current weather for any city\nğŸ”¹ 5-day detailed forecasts\nğŸ”¹ City search and suggestions\nğŸ”¹ Favorite locations\nğŸ”¹ Weather alerts\nğŸ”¹ City comparisons\nğŸ”¹ Customizable units & settings\n\nChoose a category below or type a city name to get started!",
        "help": "ğŸ†˜ <b>Weather Bot Commands</b>\n\nğŸ“ <b>Weather Commands:</b>\nâ€¢ <code>/weather [city]</code> - Current weather\nâ€¢ <code>/forecast [city]</code> - 5-day forecast\nâ€¢ <code>/alerts [city]</code> - Weather alerts\n\nğŸ” <b>Search & Discovery:</b>\nâ€¢ <code>/search [query]</code> - Find cities\nâ€¢ <code>/map [city]</code> - Weather map link\nâ€¢ <code>/compare city1,city2</code> - Compare cities\n\nâ­ <b>Favorites:</b>\nâ€¢ <code>/favorites</code> - Show favorite cities\nâ€¢ <code>/addfav [city]</code> - Add to favorites\nâ€¢ <code>/removefav [city]</code> - Remove favorite\n\nâš™ï¸ <b>Settings:</b>\nâ€¢ <code>/settings</code> - Change preferences\n\nğŸ’¡ <b>Tips:</b>\nâ€¢ Just type a city name for quick weather\nâ€¢ Use quotes for cities with spaces: 'New York'\nâ€¢ Set a default city in settings",
        "specify_city_weather": "Please specify a city! Usage: <code>/weather [city]</code>\nExample: <code>/weather London</code>\nOr set a default city in /settings",
        "specify_city_forecast": "Please specify a city! Usage: <code>/forecast [city]</code>\nExample: <code>/forecast Tokyo</code>",
        "specify_query_search": "Please provide a search query! Usage: <code>/search [query]</code>\nExample: <code>/search paris</code>",
        "no_favorites": "You don't have any favorite cities yet!\nAdd some using <code>/addfav [city]</code>",
        "favorites_list": "â­ <b>Your Favorite Cities ({count})</b>\n\nClick on any city to get current weather:",
        "specify_city_addfav": "Please specify a city! Usage: <code>/addfav [city]</code>",
        "city_not_found": "ğŸš« City '{city}' not found. Please check the spelling.",
        "added_favorite": "â­ Added '{city}' to your favorites!",
        "already_favorite": "'{city}' is already in your favorites!",
        "specify_city_removefav": "Please specify a city! Usage: <code>/removefav [city]</code>",
        "removed_favorite": "ğŸ—‘ï¸ Removed '{city}' from favorites!",
        "not_in_favorites": "'{city}' is not in your favorites!",
        "settings_menu": "âš™ï¸ <b>Settings</b>\n\nğŸŒ¡ï¸ Temperature Unit: {unit}\nğŸŒ Language: {language}\nğŸ  Default City: {default_city}\nâ­ Favorite Cities: {fav_count}\n\nClick the buttons below to change settings:",
        "specify_city_alerts": "Please specify a city! Usage: <code>/alerts [city]</code>",
        "alerts_for_city": "âš ï¸ <b>Weather Alerts for {city}</b>\n\n{alerts_list}\n\nğŸŒ¡ï¸ Current temp: {temp}",
        "no_alerts": "âœ… <b>No Weather Alerts for {city}</b>\n\nCurrent conditions are normal.",
        "error_fetching_alerts": "âŒ Could not fetch weather alerts. Please try again later.",
        "specify_cities_compare": "Please specify cities to compare!\nUsage: <code>/compare city1,city2</code>\nExample: <code>/compare London,Paris</code>",
        "not_enough_cities": "Please specify at least 2 cities separated by commas!\nExample: <code>/compare London,Paris</code>",
        "too_many_cities": "You can compare up to 4 cities at once!",
        "error_comparing_weather": "âŒ Could not compare weather data. Please try again later.",
        "specify_city_map": "Please specify a city! Usage: <code>/map [city]</code>",
        "error_generating_map": "âŒ Could not generate map links. Please try again later.",
        "map_links": "ğŸ—ºï¸ <b>Weather Maps for {city}</b>\n\nClick the links below to view interactive weather maps:",
        "no_cities_found_search": "ğŸš« No cities found matching '{query}'",
        "cities_matching_search": "ğŸ” <b>Cities matching '{query}':</b>\n\n{city_list}",
        "error_searching_cities": "âŒ Could not search for cities. Please try again later.",
        "request_timeout": "â° Request timeout. Please try again later.",
        "api_request_failed": "âŒ Sorry, I couldn't fetch weather data right now. Please try again later.",
        "unexpected_error": "âŒ An unexpected error occurred. Please try again.",
        "city_not_found_weather": "ğŸš« City '{city}' not found. Please check the spelling and try again.",
        "error_fetching_forecast": "âŒ Could not fetch forecast data. Please try again later.",
        "units_celsius": "Celsius (Â°C)",
        "units_fahrenheit": "Fahrenheit (Â°F)",
        "default_city_not_set": "Not set",
        "set_default_city_instructions": "ğŸ  To set a default city, use the command:\n<code>/addfav [city]</code> then come back to settings.\n\nOr just type a city name and I'll remember it!",
        "manage_favorites_menu": "â­ <b>Manage Favorite Cities</b>\n\nClick to remove a city:",
        "reset_settings_confirm": "âœ… All settings have been reset to default!",
        "manage_favorites_back": "â¬…ï¸ Back to Settings",
        "add_to_favorites_button": "â­ Add to Favorites",
        "manage_favorites_button": "âš™ï¸ Manage Favorites",
        "openweather_map_button": "ğŸ—ºï¸ OpenWeather Map",
        "Maps_button": "ğŸ“ Google Maps",
        "temperature_comparison": "ğŸŒ¡ï¸ <b>Temperature ({unit_symbol})</b>\n",
        "humidity_comparison": "ğŸ’§ <b>Humidity (%)</b>\n",
        "current_conditions_comparison": "â˜ï¸ <b>Current Conditions</b>\n",
        "highlights_comparison": "\nğŸ… <b>Highlights</b>\n",
        "hottest": "ğŸ”¥ Hottest: {city} ({temp:.1f}{unit_symbol})",
        "coldest": "ğŸ§Š Coldest: {city} ({temp:.1f}{unit_symbol})",
        "most_humid": "ğŸ’§ Most Humid: {city} ({humidity}%)",
        "weather_comparison_title": "ğŸ† <b>Weather Comparison</b>\n\n",
        "units_toggle_button": "ğŸŒ¡ï¸ Units: {unit_name}",
        "language_toggle_button": "ğŸŒ Language: {language_name}",
        "default_city_button": "ğŸ  Default City: {city_name}",
        "reset_settings_button": "ğŸ—‘ï¸ Reset All Settings",
        "choose_language": "ğŸŒ <b>Choose your language:</b>",
        "language_set": "ğŸŒ Language set to {language_name}!",
        "english": "English",
        "arabic": "Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©",
        "current_weather_button": "ğŸŒ¤ï¸ Current Weather",
        "five_day_forecast_button": "ğŸ“Š 5-Day Forecast",
        "search_cities_button": "ğŸ” Search Cities",
        "favorites_button": "â­ Favorites",
        "settings_button": "âš™ï¸ Settings",
        "weather_in_city": "Current Weather in {city}, {country}",
        "temperature": "Temperature",
        "feels_like": "Feels like",
        "humidity": "Humidity",
        "pressure": "Pressure",
        "wind": "Wind",
        "cloudiness": "Cloudiness",
        "visibility": "Visibility",
        "conditions": "Conditions",
        "sunrise": "Sunrise",
        "sunset": "Sunset",
        "meters_per_second": "m/s",
        "miles_per_hour": "mph",
        "forecast_for_city": "5-Day Forecast for {city}, {country}",
        "extreme_heat_warning": "Extreme Heat Warning!",
        "extreme_cold_warning": "Extreme Cold Warning!",
        "high_wind_alert": "High Wind Alert!",
        "high_humidity_alert": "High Humidity Alert!",
        "thunderstorm_alert": "Thunderstorm Alert!",
        "heavy_rain_alert": "Heavy Rain Alert!",
        "snow_alert": "Snow Alert!",
        "error_fetching_data_any_cities": "âŒ Could not fetch weather data for some cities. Please try again later."
    },
    "ar": {
        "welcome": "ğŸŒ¤ï¸ <b>Ø£Ù‡Ù„Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ø¨ÙˆØª Ø§Ù„Ø·Ù‚Ø³ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…!</b> ğŸŒ¤ï¸\n\nØ£Ù†Ø§ Ù…Ø³Ø§Ø¹Ø¯Ùƒ Ø§Ù„Ø´Ø§Ù…Ù„ Ù„Ù„Ø·Ù‚Ø³ Ù…Ø¹ Ø§Ù„Ø¹Ø¯ÙŠØ¯ Ù…Ù† Ø§Ù„Ù…ÙŠØ²Ø§Øª:\n\nğŸ”¹ Ø§Ù„Ø·Ù‚Ø³ Ø§Ù„Ø­Ø§Ù„ÙŠ Ù„Ø£ÙŠ Ù…Ø¯ÙŠÙ†Ø©\nğŸ”¹ ØªÙˆÙ‚Ø¹Ø§Øª Ù…ÙØµÙ„Ø© Ù„Ù…Ø¯Ø© 5 Ø£ÙŠØ§Ù…\nğŸ”¹ Ø¨Ø­Ø« Ø§Ù„Ù…Ø¯Ù† ÙˆØ§Ù‚ØªØ±Ø§Ø­Ø§ØªÙ‡Ø§\nğŸ”¹ Ø§Ù„Ù…ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù…ÙØ¶Ù„Ø©\nğŸ”¹ ØªÙ†Ø¨ÙŠÙ‡Ø§Øª Ø§Ù„Ø·Ù‚Ø³\nğŸ”¹ Ù…Ù‚Ø§Ø±Ù†Ø© Ø§Ù„Ù…Ø¯Ù†\nğŸ”¹ ÙˆØ­Ø¯Ø§Øª ÙˆØ¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„ØªØ®ØµÙŠØµ\n\nØ§Ø®ØªØ± ÙØ¦Ø© Ø£Ø¯Ù†Ø§Ù‡ Ø£Ùˆ Ø§ÙƒØªØ¨ Ø§Ø³Ù… Ù…Ø¯ÙŠÙ†Ø© Ù„Ù„Ø¨Ø¯Ø¡!",
        "help": "ğŸ†˜ <b>Ø£ÙˆØ§Ù…Ø± Ø¨ÙˆØª Ø§Ù„Ø·Ù‚Ø³</b>\n\nğŸ“ <b>Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø·Ù‚Ø³:</b>\nâ€¢ <code>/weather [Ù…Ø¯ÙŠÙ†Ø©]</code> - Ø§Ù„Ø·Ù‚Ø³ Ø§Ù„Ø­Ø§Ù„ÙŠ\nâ€¢ <code>/forecast [Ù…Ø¯ÙŠÙ†Ø©]</code> - ØªÙˆÙ‚Ø¹Ø§Øª 5 Ø£ÙŠØ§Ù…\nâ€¢ <code>/alerts [Ù…Ø¯ÙŠÙ†Ø©]</code> - ØªÙ†Ø¨ÙŠÙ‡Ø§Øª Ø§Ù„Ø·Ù‚Ø³\n\nğŸ” <b>Ø§Ù„Ø¨Ø­Ø« ÙˆØ§Ù„Ø§ÙƒØªØ´Ø§Ù:</b>\nâ€¢ <code>/search [Ø§Ø³ØªØ¹Ù„Ø§Ù…]</code> - Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ù…Ø¯Ù†\nâ€¢ <code>/map [Ù…Ø¯ÙŠÙ†Ø©]</code> - Ø±Ø§Ø¨Ø· Ø®Ø±ÙŠØ·Ø© Ø§Ù„Ø·Ù‚Ø³\nâ€¢ <code>/compare Ù…Ø¯ÙŠÙ†Ø©1,Ù…Ø¯ÙŠÙ†Ø©2</code> - Ù…Ù‚Ø§Ø±Ù†Ø© Ø§Ù„Ù…Ø¯Ù†\n\nâ­ <b>Ø§Ù„Ù…ÙØ¶Ù„Ø©:</b>\nâ€¢ <code>/favorites</code> - Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø¯Ù† Ø§Ù„Ù…ÙØ¶Ù„Ø©\nâ€¢ <code>/addfav [Ù…Ø¯ÙŠÙ†Ø©]</code> - Ø¥Ø¶Ø§ÙØ© Ø¥Ù„Ù‰ Ø§Ù„Ù…ÙØ¶Ù„Ø©\nâ€¢ <code>/removefav [Ù…Ø¯ÙŠÙ†Ø©]</code> - Ø¥Ø²Ø§Ù„Ø© Ù…Ù† Ø§Ù„Ù…ÙØ¶Ù„Ø©\n\nâš™ï¸ <b>Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª:</b>\nâ€¢ <code>/settings</code> - ØªØºÙŠÙŠØ± Ø§Ù„ØªÙØ¶ÙŠÙ„Ø§Øª\n\nğŸ’¡ <b>Ù†ØµØ§Ø¦Ø­:</b>\nâ€¢ ÙÙ‚Ø· Ø§ÙƒØªØ¨ Ø§Ø³Ù… Ù…Ø¯ÙŠÙ†Ø© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø·Ù‚Ø³ Ø§Ù„Ø³Ø±ÙŠØ¹\nâ€¢ Ø§Ø³ØªØ®Ø¯Ù… Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„Ø§Ù‚ØªØ¨Ø§Ø³ Ù„Ù„Ù…Ø¯Ù† Ø§Ù„ØªÙŠ ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ù…Ø³Ø§ÙØ§Øª: 'Ù†ÙŠÙˆÙŠÙˆØ±Ùƒ'\nâ€¢ Ù‚Ù… Ø¨ØªØ¹ÙŠÙŠÙ† Ù…Ø¯ÙŠÙ†Ø© Ø§ÙØªØ±Ø§Ø¶ÙŠØ© ÙÙŠ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª",
        "specify_city_weather": "Ø§Ù„Ø±Ø¬Ø§Ø¡ ØªØ­Ø¯ÙŠØ¯ Ù…Ø¯ÙŠÙ†Ø©! Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…: <code>/weather [Ù…Ø¯ÙŠÙ†Ø©]</code>\nÙ…Ø«Ø§Ù„: <code>/weather Ù„Ù†Ø¯Ù†</code>\nØ£Ùˆ Ù‚Ù… Ø¨ØªØ¹ÙŠÙŠÙ† Ù…Ø¯ÙŠÙ†Ø© Ø§ÙØªØ±Ø§Ø¶ÙŠØ© ÙÙŠ /settings",
        "specify_city_forecast": "Ø§Ù„Ø±Ø¬Ø§Ø¡ ØªØ­Ø¯ÙŠØ¯ Ù…Ø¯ÙŠÙ†Ø©! Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…: <code>/forecast [Ù…Ø¯ÙŠÙ†Ø©]</code>\nÙ…Ø«Ø§Ù„: <code>/forecast Ø·ÙˆÙƒÙŠÙˆ</code>",
        "specify_query_search": "Ø§Ù„Ø±Ø¬Ø§Ø¡ ØªÙ‚Ø¯ÙŠÙ… Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø¨Ø­Ø«! Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…: <code>/search [Ø§Ø³ØªØ¹Ù„Ø§Ù…]</code>\nÙ…Ø«Ø§Ù„: <code>/search Ø¨Ø§Ø±ÙŠØ³</code>",
        "no_favorites": "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø£ÙŠ Ù…Ø¯Ù† Ù…ÙØ¶Ù„Ø© Ø¨Ø¹Ø¯!\nØ£Ø¶Ù Ø¨Ø¹Ø¶Ù‡Ø§ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… <code>/addfav [Ù…Ø¯ÙŠÙ†Ø©]</code>",
        "favorites_list": "â­ <b>Ù…Ø¯Ù†Ùƒ Ø§Ù„Ù…ÙØ¶Ù„Ø© ({count})</b>\n\nØ§Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ø£ÙŠ Ù…Ø¯ÙŠÙ†Ø© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø·Ù‚Ø³ Ø§Ù„Ø­Ø§Ù„ÙŠ:",
        "specify_city_addfav": "Ø§Ù„Ø±Ø¬Ø§Ø¡ ØªØ­Ø¯ÙŠØ¯ Ù…Ø¯ÙŠÙ†Ø©! Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…: <code>/addfav [Ù…Ø¯ÙŠÙ†Ø©]</code>",
        "city_not_found": "ğŸš« Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ø¯ÙŠÙ†Ø© '{city}'. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¥Ù…Ù„Ø§Ø¡.",
        "added_favorite": "â­ ØªÙ…Øª Ø¥Ø¶Ø§ÙØ© '{city}' Ø¥Ù„Ù‰ Ù…ÙØ¶Ù„Ø§ØªÙƒ!",
        "already_favorite": "'{city}' Ù…ÙˆØ¬ÙˆØ¯Ø© Ø¨Ø§Ù„ÙØ¹Ù„ ÙÙŠ Ù…ÙØ¶Ù„Ø§ØªÙƒ!",
        "specify_city_removefav": "Ø§Ù„Ø±Ø¬Ø§Ø¡ ØªØ­Ø¯ÙŠØ¯ Ù…Ø¯ÙŠÙ†Ø©! Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…: <code>/removefav [Ù…Ø¯ÙŠÙ†Ø©]</code>",
        "removed_favorite": "ğŸ—‘ï¸ ØªÙ…Øª Ø¥Ø²Ø§Ù„Ø© '{city}' Ù…Ù† Ø§Ù„Ù…ÙØ¶Ù„Ø©!",
        "not_in_favorites": "'{city}' Ù„ÙŠØ³Øª ÙÙŠ Ù…ÙØ¶Ù„Ø§ØªÙƒ!",
        "settings_menu": "âš™ï¸ <b>Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª</b>\n\nğŸŒ¡ï¸ ÙˆØ­Ø¯Ø© Ø§Ù„Ø­Ø±Ø§Ø±Ø©: {unit}\nğŸŒ Ø§Ù„Ù„ØºØ©: {language}\nğŸ  Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©: {default_city}\nâ­ Ø§Ù„Ù…Ø¯Ù† Ø§Ù„Ù…ÙØ¶Ù„Ø©: {fav_count}\n\nØ§Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø£Ø¯Ù†Ø§Ù‡ Ù„ØªØºÙŠÙŠØ± Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª:",
        "specify_city_alerts": "Ø§Ù„Ø±Ø¬Ø§Ø¡ ØªØ­Ø¯ÙŠØ¯ Ù…Ø¯ÙŠÙ†Ø©! Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…: <code>/alerts [Ù…Ø¯ÙŠÙ†Ø©]</code>",
        "alerts_for_city": "âš ï¸ <b>ØªÙ†Ø¨ÙŠÙ‡Ø§Øª Ø§Ù„Ø·Ù‚Ø³ Ù„Ù€ {city}</b>\n\n{alerts_list}\n\nğŸŒ¡ï¸ Ø¯Ø±Ø¬Ø© Ø§Ù„Ø­Ø±Ø§Ø±Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©: {temp}",
        "no_alerts": "âœ… <b>Ù„Ø§ ØªÙˆØ¬Ø¯ ØªÙ†Ø¨ÙŠÙ‡Ø§Øª Ø·Ù‚Ø³ Ù„Ù€ {city}</b>\n\nØ§Ù„Ø¸Ø±ÙˆÙ Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ø·Ø¨ÙŠØ¹ÙŠØ©.",
        "error_fetching_alerts": "âŒ ØªØ¹Ø°Ø± Ø¬Ù„Ø¨ ØªÙ†Ø¨ÙŠÙ‡Ø§Øª Ø§Ù„Ø·Ù‚Ø³. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ù„Ø§Ø­Ù‚Ù‹Ø§.",
        "specify_cities_compare": "Ø§Ù„Ø±Ø¬Ø§Ø¡ ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…Ø¯Ù† Ù„Ù„Ù…Ù‚Ø§Ø±Ù†Ø©!\nØ§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…: <code>/compare Ù…Ø¯ÙŠÙ†Ø©1,Ù…Ø¯ÙŠÙ†Ø©2</code>\nÙ…Ø«Ø§Ù„: <code>/compare Ù„Ù†Ø¯Ù†,Ø¨Ø§Ø±ÙŠØ³</code>",
        "not_enough_cities": "Ø§Ù„Ø±Ø¬Ø§Ø¡ ØªØ­Ø¯ÙŠØ¯ Ù…Ø¯ÙŠÙ†ØªÙŠÙ† Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„ Ù…ÙØµÙˆÙ„Ø© Ø¨ÙÙˆØ§ØµÙ„!\nÙ…Ø«Ø§Ù„: <code>/compare Ù„Ù†Ø¯Ù†,Ø¨Ø§Ø±ÙŠØ³</code>",
        "too_many_cities": "ÙŠÙ…ÙƒÙ†Ùƒ Ù…Ù‚Ø§Ø±Ù†Ø© Ù…Ø§ ÙŠØµÙ„ Ø¥Ù„Ù‰ 4 Ù…Ø¯Ù† ÙÙŠ ÙˆÙ‚Øª ÙˆØ§Ø­Ø¯!",
        "error_comparing_weather": "âŒ ØªØ¹Ø°Ø± Ù…Ù‚Ø§Ø±Ù†Ø© Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø·Ù‚Ø³. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ù„Ø§Ø­Ù‚Ù‹Ø§.",
        "specify_city_map": "Ø§Ù„Ø±Ø¬Ø§Ø¡ ØªØ­Ø¯ÙŠØ¯ Ù…Ø¯ÙŠÙ†Ø©! Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…: <code>/map [Ù…Ø¯ÙŠÙ†Ø©]</code>",
        "error_generating_map": "âŒ ØªØ¹Ø°Ø± Ø¥Ù†Ø´Ø§Ø¡ Ø±ÙˆØ§Ø¨Ø· Ø§Ù„Ø®Ø±Ø§Ø¦Ø·. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ù„Ø§Ø­Ù‚Ù‹Ø§.",
        "map_links": "ğŸ—ºï¸ <b>Ø®Ø±Ø§Ø¦Ø· Ø§Ù„Ø·Ù‚Ø³ Ù„Ù€ {city}</b>\n\nØ§Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ø§Ù„Ø±ÙˆØ§Ø¨Ø· Ø£Ø¯Ù†Ø§Ù‡ Ù„Ø¹Ø±Ø¶ Ø®Ø±Ø§Ø¦Ø· Ø§Ù„Ø·Ù‚Ø³ Ø§Ù„ØªÙØ§Ø¹Ù„ÙŠØ©:",
        "no_cities_found_search": "ğŸš« Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ø¯Ù† Ù…Ø·Ø§Ø¨Ù‚Ø© Ù„Ù€ '{query}'",
        "cities_matching_search": "ğŸ” <b>Ø§Ù„Ù…Ø¯Ù† Ø§Ù„Ù…Ø·Ø§Ø¨Ù‚Ø© Ù„Ù€ '{query}':</b>\n\n{city_list}",
        "error_searching_cities": "âŒ ØªØ¹Ø°Ø± Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ù…Ø¯Ù†. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ù„Ø§Ø­Ù‚Ù‹Ø§.",
        "request_timeout": "â° Ø§Ù†ØªÙ‡Øª Ù…Ù‡Ù„Ø© Ø§Ù„Ø·Ù„Ø¨. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ù„Ø§Ø­Ù‚Ù‹Ø§.",
        "api_request_failed": "âŒ Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù„Ù… Ø£ØªÙ…ÙƒÙ† Ù…Ù† Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø·Ù‚Ø³ Ø§Ù„Ø¢Ù†. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ù„Ø§Ø­Ù‚Ù‹Ø§.",
        "unexpected_error": "âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.",
        "city_not_found_weather": "ğŸš« Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ø¯ÙŠÙ†Ø© '{city}'. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¥Ù…Ù„Ø§Ø¡ ÙˆØ§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.",
        "error_fetching_forecast": "âŒ ØªØ¹Ø°Ø± Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªÙˆÙ‚Ø¹Ø§Øª. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ù„Ø§Ø­Ù‚Ù‹Ø§.",
        "units_celsius": "Ù…Ø¦ÙˆÙŠØ© (Â°Ù…)",
        "units_fahrenheit": "ÙÙ‡Ø±Ù†Ù‡Ø§ÙŠØª (Â°Ù)",
        "default_city_not_set": "Ù„Ù… ÙŠØªÙ… Ø§Ù„ØªØ¹ÙŠÙŠÙ†",
        "set_default_city_instructions": "ğŸ  Ù„ØªØ¹ÙŠÙŠÙ† Ù…Ø¯ÙŠÙ†Ø© Ø§ÙØªØ±Ø§Ø¶ÙŠØ©ØŒ Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ù…Ø±:\n<code>/addfav [Ù…Ø¯ÙŠÙ†Ø©]</code> Ø«Ù… Ø§Ø±Ø¬Ø¹ Ø¥Ù„Ù‰ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª.\n\nØ£Ùˆ ÙÙ‚Ø· Ø§ÙƒØªØ¨ Ø§Ø³Ù… Ù…Ø¯ÙŠÙ†Ø© ÙˆØ³Ø£ØªØ°ÙƒØ±Ù‡Ø§!",
        "manage_favorites_menu": "â­ <b>Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø¯Ù† Ø§Ù„Ù…ÙØ¶Ù„Ø©</b>\n\nØ§Ù†Ù‚Ø± Ù„Ø¥Ø²Ø§Ù„Ø© Ù…Ø¯ÙŠÙ†Ø©:",
        "reset_settings_confirm": "âœ… ØªÙ… Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø¥Ù„Ù‰ Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ!",
        "manage_favorites_back": "â¬…ï¸ Ø§Ù„Ø¹ÙˆØ¯Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª",
        "add_to_favorites_button": "â­ Ø¥Ø¶Ø§ÙØ© Ø¥Ù„Ù‰ Ø§Ù„Ù…ÙØ¶Ù„Ø©",
        "manage_favorites_button": "âš™ï¸ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…ÙØ¶Ù„Ø©",
        "openweather_map_button": "ğŸ—ºï¸ Ø®Ø±ÙŠØ·Ø© OpenWeather",
        "Maps_button": "ğŸ“ Ø®Ø±Ø§Ø¦Ø· Ø¬ÙˆØ¬Ù„",
        "temperature_comparison": "ğŸŒ¡ï¸ <b>Ø¯Ø±Ø¬Ø© Ø§Ù„Ø­Ø±Ø§Ø±Ø© ({unit_symbol})</b>\n",
        "humidity_comparison": "ğŸ’§ <b>Ø§Ù„Ø±Ø·ÙˆØ¨Ø© (%)</b>\n",
        "current_conditions_comparison": "â˜ï¸ <b>Ø§Ù„Ø¸Ø±ÙˆÙ Ø§Ù„Ø­Ø§Ù„ÙŠØ©</b>\n",
        "highlights_comparison": "\nğŸ… <b>Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©</b>\n",
        "hottest": "ğŸ”¥ Ø§Ù„Ø£ÙƒØ«Ø± Ø­Ø±Ø§Ø±Ø©: {city} ({temp:.1f}{unit_symbol})",
        "coldest": "ğŸ§Š Ø§Ù„Ø£Ø¨Ø±Ø¯: {city} ({temp:.1f}{unit_symbol})",
        "most_humid": "ğŸ’§ Ø§Ù„Ø£ÙƒØ«Ø± Ø±Ø·ÙˆØ¨Ø©: {city} ({humidity}%)",
        "weather_comparison_title": "ğŸ† <b>Ù…Ù‚Ø§Ø±Ù†Ø© Ø§Ù„Ø·Ù‚Ø³</b>\n\n",
        "units_toggle_button": "ğŸŒ¡ï¸ Ø§Ù„ÙˆØ­Ø¯Ø§Øª: {unit_name}",
        "language_toggle_button": "ğŸŒ Ø§Ù„Ù„ØºØ©: {language_name}",
        "default_city_button": "ğŸ  Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©: {city_name}",
        "reset_settings_button": "ğŸ—‘ï¸ Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª",
        "choose_language": "ğŸŒ <b>Ø§Ø®ØªØ± Ù„ØºØªÙƒ:</b>",
        "language_set": "ğŸŒ ØªÙ… ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ù„ØºØ© Ø¥Ù„Ù‰ {language_name}!",
        "english": "Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©",
        "arabic": "Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©",
        "current_weather_button": "ğŸŒ¤ï¸ Ø§Ù„Ø·Ù‚Ø³ Ø§Ù„Ø­Ø§Ù„ÙŠ",
        "five_day_forecast_button": "ğŸ“Š ØªÙˆÙ‚Ø¹Ø§Øª 5 Ø£ÙŠØ§Ù…",
        "search_cities_button": "ğŸ” Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ù…Ø¯Ù†",
        "favorites_button": "â­ Ø§Ù„Ù…ÙØ¶Ù„Ø©",
        "settings_button": "âš™ï¸ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª",
        "weather_in_city": "Ø§Ù„Ø·Ù‚Ø³ Ø§Ù„Ø­Ø§Ù„ÙŠ ÙÙŠ {city}, {country}",
        "temperature": "Ø¯Ø±Ø¬Ø© Ø§Ù„Ø­Ø±Ø§Ø±Ø©",
        "feels_like": "Ø§Ù„Ø´Ø¹ÙˆØ± ÙƒØ£Ù†",
        "humidity": "Ø§Ù„Ø±Ø·ÙˆØ¨Ø©",
        "pressure": "Ø§Ù„Ø¶ØºØ·",
        "wind": "Ø§Ù„Ø±ÙŠØ§Ø­",
        "cloudiness": "Ø§Ù„ØºÙŠÙˆÙ…",
        "visibility": "Ø§Ù„Ø±Ø¤ÙŠØ©",
        "conditions": "Ø§Ù„Ø¸Ø±ÙˆÙ",
        "sunrise": "Ø´Ø±ÙˆÙ‚ Ø§Ù„Ø´Ù…Ø³",
        "sunset": "ØºØ±ÙˆØ¨ Ø§Ù„Ø´Ù…Ø³",
        "meters_per_second": "Ù…/Ø«",
        "miles_per_hour": "Ù…ÙŠÙ„/Ø³Ø§Ø¹Ø©",
        "forecast_for_city": "ØªÙˆÙ‚Ø¹Ø§Øª 5 Ø£ÙŠØ§Ù… Ù„Ù€ {city}, {country}",
        "extreme_heat_warning": "ØªØ­Ø°ÙŠØ± Ù…Ù† Ø­Ø±Ø§Ø±Ø© Ø´Ø¯ÙŠØ¯Ø©!",
        "extreme_cold_warning": "ØªØ­Ø°ÙŠØ± Ù…Ù† Ø¨Ø±Ø¯ Ø´Ø¯ÙŠØ¯!",
        "high_wind_alert": "ØªØ­Ø°ÙŠØ± Ù…Ù† Ø±ÙŠØ§Ø­ Ù‚ÙˆÙŠØ©!",
        "high_humidity_alert": "ØªØ­Ø°ÙŠØ± Ù…Ù† Ø±Ø·ÙˆØ¨Ø© Ø¹Ø§Ù„ÙŠØ©!",
        "thunderstorm_alert": "ØªØ­Ø°ÙŠØ± Ù…Ù† Ø¹Ø§ØµÙØ© Ø±Ø¹Ø¯ÙŠØ©!",
        "heavy_rain_alert": "ØªØ­Ø°ÙŠØ± Ù…Ù† Ø£Ù…Ø·Ø§Ø± ØºØ²ÙŠØ±Ø©!",
        "snow_alert": "ØªØ­Ø°ÙŠØ± Ù…Ù† ØªØ³Ø§Ù‚Ø· Ø«Ù„ÙˆØ¬!",
        "error_fetching_data_any_cities": "âŒ ØªØ¹Ø°Ø± Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø·Ù‚Ø³ Ù„Ø¨Ø¹Ø¶ Ø§Ù„Ù…Ø¯Ù†. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ù„Ø§Ø­Ù‚Ù‹Ø§."
    }
}

def get_localized_message(user_language: str, key: str, **kwargs) -> str:
    """Get a localized message based on user's language."""
    return MESSAGES.get(user_language, MESSAGES["en"]).get(key, MESSAGES["en"][key]).format(**kwargs)
</file>

<file path="main.py">
import logging
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, filters, ContextTypes

# Import modules from your new structure
from config import TELEGRAM_BOT_TOKEN, WEATHER_API_KEY
from data_store import UserDataStore
from weather_api import WeatherAPI
from handlers import command_handlers, callback_handlers # Import the handler modules

# Enable logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

def main():
    """Starts the bot."""
    if not TELEGRAM_BOT_TOKEN or not WEATHER_API_KEY:
        logger.error("Bot cannot start: Missing required environment variables. Please check config.py or your .env file.")
        return

    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()

    # Initialize shared resources and store them in bot_data
    user_data_store = UserDataStore()
    weather_api_client = WeatherAPI(WEATHER_API_KEY)
    
    application.bot_data['user_data_store'] = user_data_store
    application.bot_data['weather_api_client'] = weather_api_client

    # Command handlers
    application.add_handler(CommandHandler("start", command_handlers.start_command))
    application.add_handler(CommandHandler("help", command_handlers.help_command))
    application.add_handler(CommandHandler("weather", command_handlers.weather_command))
    application.add_handler(CommandHandler("forecast", command_handlers.forecast_command))
    application.add_handler(CommandHandler("search", command_handlers.search_cities))
    application.add_handler(CommandHandler("favorites", command_handlers.favorites_command))
    application.add_handler(CommandHandler("addfav", command_handlers.add_favorite))
    application.add_handler(CommandHandler("removefav", command_handlers.remove_favorite))
    application.add_handler(CommandHandler("settings", command_handlers.settings_command))
    application.add_handler(CommandHandler("alerts", command_handlers.weather_alerts))
    application.add_handler(CommandHandler("compare", command_handlers.compare_cities))
    application.add_handler(CommandHandler("map", command_handlers.weather_map))
    
    # Callback query handler for inline keyboards
    application.add_handler(CallbackQueryHandler(callback_handlers.handle_callback))
    
    # Message handler for city names
    application.add_handler(MessageHandler(
        filters.TEXT & ~filters.COMMAND, 
        command_handlers.handle_city_message
    ))

    # Error handler
    application.add_error_handler(error_handler)

    print("ğŸš€ Starting Enhanced Weather Bot...")
    application.run_polling(allowed_updates=Update.ALL_TYPES)

async def error_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle errors."""
    logger.error(f"Exception while handling an update: {context.error}")
    if update and update.effective_message:
        user_id = update.effective_user.id
        user_data_store = context.bot_data.get('user_data_store')
        prefs = user_data_store.get_user_prefs(user_id)
        await update.effective_message.reply_text(get_localized_message(prefs.language, "unexpected_error"))


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print("\nğŸ›‘ Bot stopped by user")
    except Exception as e:
        logger.critical(f"Failed to start bot: {e}")
        print(f"âŒ Critical Error: {e}")
</file>

<file path="utils.py">
from datetime import datetime
from localization import get_localized_message
from typing import Dict, Any

def get_weather_emoji(weather_id: int) -> str:
    """Get appropriate emoji for weather condition based on OpenWeatherMap weather ID."""
    if weather_id < 300:
        return "â›ˆï¸"  # Thunderstorm
    elif weather_id < 400:
        return "ğŸŒ¦ï¸"  # Drizzle
    elif weather_id < 600:
        return "ğŸŒ§ï¸"  # Rain
    elif weather_id < 700:
        return "â„ï¸"  # Snow
    elif weather_id < 800:
        return "ğŸŒ«ï¸"  # Atmosphere (fog, mist, etc.)
    elif weather_id == 800:
        return "â˜€ï¸"  # Clear sky
    else:
        return "â˜ï¸"  # Clouds

def format_weather_message(data: Dict[str, Any], prefs_lang: str, unit: str) -> str:
    """Format current weather data into a readable message."""
    city = data['name']
    country = data['sys']['country']
    temp = data['main']['temp']
    feels_like = data['main']['feels_like']
    humidity = data['main']['humidity']
    pressure = data['main']['pressure']
    description = data['weather'][0]['description'].title()
    
    wind_speed = data.get('wind', {}).get('speed', 0)
    wind_deg = data.get('wind', {}).get('deg', 0)
    visibility = data.get('visibility', 0) / 1000 if data.get('visibility') else None
    clouds = data.get('clouds', {}).get('all', 0)
    
    sunrise = datetime.fromtimestamp(data['sys']['sunrise']).strftime('%H:%M')
    sunset = datetime.fromtimestamp(data['sys']['sunset']).strftime('%H:%M')
    
    weather_id = data['weather'][0]['id']
    emoji = get_weather_emoji(weather_id)
    
    if unit == 'metric':
        temp_unit = "Â°C"
        speed_unit = get_localized_message(prefs_lang, "meters_per_second")
    else:
        temp_unit = "Â°F"
        speed_unit = get_localized_message(prefs_lang, "miles_per_hour")
    
    temp = round(temp)
    feels_like = round(feels_like)

    # Simplified wind direction logic
    wind_directions = ["N", "NNE", "NE", "ENE", "E", "ESE", "SE", "SSE",
                      "S", "SSW", "SW", "WSW", "W", "WNW", "NW", "NNW"]
    wind_dir = wind_directions[round(wind_deg / 22.5) % 16] if wind_deg is not None else "N/A"
    
    message = (
        f"{emoji} <b>{get_localized_message(prefs_lang, 'weather_in_city', city=city, country=country)}</b>\n\n"
        f"ğŸŒ¡ï¸ {get_localized_message(prefs_lang, 'temperature')}: {temp}{temp_unit}\n"
        f"ğŸ¤” {get_localized_message(prefs_lang, 'feels_like')}: {feels_like}{temp_unit}\n"
        f"ğŸ’§ {get_localized_message(prefs_lang, 'humidity')}: {humidity}%\n"
        f"ğŸ“Š {get_localized_message(prefs_lang, 'pressure')}: {pressure} hPa\n"
        f"ğŸ’¨ {get_localized_message(prefs_lang, 'wind')}: {wind_speed:.1f} {speed_unit} {wind_dir}\n"
        f"â˜ï¸ {get_localized_message(prefs_lang, 'cloudiness')}: {clouds}%\n"
    )
    
    if visibility is not None:
        message += f"ğŸ‘ï¸ {get_localized_message(prefs_lang, 'visibility')}: {visibility:.1f} km\n"
    
    message += (
        f"ğŸ“ {get_localized_message(prefs_lang, 'conditions')}: {description}\n\n"
        f"ğŸŒ… {get_localized_message(prefs_lang, 'sunrise')}: {sunrise}\n"
        f"ğŸŒ‡ {get_localized_message(prefs_lang, 'sunset')}: {sunset}"
    )
    
    return message

def format_forecast_message(data: Dict[str, Any], prefs_lang: str, unit: str) -> str:
    """Format 5-day forecast data into a readable message."""
    city = data['city']['name']
    country = data['city']['country']
    
    unit_symbol = "Â°C" if unit == "metric" else "Â°F"
    
    message = get_localized_message(prefs_lang, "forecast_for_city", city=city, country=country) + "\n\n"
    
    daily_forecasts = {}
    for item in data['list']:
        date = datetime.fromtimestamp(item['dt']).date()
        if date not in daily_forecasts:
            daily_forecasts[date] = []
        daily_forecasts[date].append(item)
    
    for i, (date, forecasts) in enumerate(list(daily_forecasts.items())[:5]):
        day_name = date.strftime('%A')
        date_str = date.strftime('%m/%d')
        
        temps = [f['main']['temp'] for f in forecasts]
        min_temp = min(temps)
        max_temp = max(temps)
        
        conditions = [f['weather'][0] for f in forecasts]
        main_condition_group = max(set(c['main'] for c in conditions), 
                                   key=[c['main'] for c in conditions].count)
        
        # Get a representative description, prefer one matching the main condition group
        representative_description = next((c['description'].title() for c in conditions if c['main'] == main_condition_group), conditions[0]['description'].title())
        
        weather_ids = [c['id'] for c in conditions if c['main'] == main_condition_group]
        representative_id = weather_ids[0] if weather_ids else conditions[0]['id']
        
        emoji = get_weather_emoji(representative_id)
        
        pop = max([f.get('pop', 0) for f in forecasts]) * 100
        
        message += f"{emoji} <b>{day_name} ({date_str})</b>\n"
        message += f"   ğŸŒ¡ï¸ {min_temp:.0f}{unit_symbol} - {max_temp:.0f}{unit_symbol}"
        
        if pop > 20:
            message += f" | ğŸŒ§ï¸ {pop:.0f}%"
        
        message += f"\n   ğŸ“ {representative_description}\n\n"
        
    return message
</file>

<file path="weather_api.py">
import requests
import logging
from typing import Dict, Any, Optional
from config import WEATHER_API_KEY, WEATHER_API_URL, FORECAST_API_URL, GEOCODING_API_URL, REQUEST_TIMEOUT

logger = logging.getLogger(__name__)

class WeatherAPI:
    def __init__(self, api_key: str):
        self.api_key = api_key

    async def get_current_weather(self, city: str, unit: str, lang: str) -> Optional[Dict[str, Any]]:
        """Fetches current weather data for a given city."""
        params = {
            'q': city,
            'appid': self.api_key,
            'units': unit,
            'lang': lang
        }
        try:
            response = requests.get(WEATHER_API_URL, params=params, timeout=REQUEST_TIMEOUT)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.Timeout:
            logger.error(f"Weather API request timed out for {city}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"Error fetching current weather for {city}: {e}")
            if response.status_code == 404:
                return {"error": "city_not_found"}
            return None

    async def get_five_day_forecast(self, city: str, unit: str, lang: str) -> Optional[Dict[str, Any]]:
        """Fetches 5-day weather forecast data for a given city."""
        params = {
            'q': city,
            'appid': self.api_key,
            'units': unit,
            'lang': lang
        }
        try:
            response = requests.get(FORECAST_API_URL, params=params, timeout=REQUEST_TIMEOUT)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.Timeout:
            logger.error(f"Forecast API request timed out for {city}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"Error fetching forecast for {city}: {e}")
            if response.status_code == 404:
                return {"error": "city_not_found"}
            return None

    async def get_city_coordinates(self, query: str) -> Optional[list]:
        """Fetches geographical coordinates for a city query."""
        params = {
            'q': query,
            'appid': self.api_key,
            'limit': 10
        }
        try:
            response = requests.get(GEOCODING_API_URL, params=params, timeout=REQUEST_TIMEOUT)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.Timeout:
            logger.error(f"Geocoding API request timed out for {query}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"Error fetching coordinates for {query}: {e}")
            return None

    async def verify_city_exists(self, city: str, lang: str) -> bool:
        """Verifies if a city exists by trying to fetch its current weather."""
        params = {
            'q': city,
            'appid': self.api_key,
            'units': 'metric', # Unit doesn't matter for existence check
            'lang': lang
        }
        try:
            response = requests.get(WEATHER_API_URL, params=params, timeout=5)
            return response.status_code == 200
        except requests.exceptions.RequestException as e:
            logger.error(f"Error verifying city {city}: {e}")
            return False
</file>

<file path="docker-compose.yml">
version: '3.8'

services:
  weather-bot:
    build: .
    container_name: telegram-weather-bot
    restart: unless-stopped
    env_file:
      - .env
    environment:
      - PYTHONUNBUFFERED=1
    volumes:
      # Optional: Mount logs directory
      - ./logs:/app/logs
    networks:
      - bot-network

    # Optional: Resource limits
    deploy:
      resources:
        limits:
          memory: 128M
          cpus: '0.1'
        reservations:
          memory: 64M
          cpus: '0.05'

networks:
  bot-network:
    driver: bridge
</file>

<file path="Dockerfile">
# Dockerfile
FROM python:3.11-slim

# Set working directory
WORKDIR /app

# Copy requirements first (for better caching)
COPY requirements.txt .

# Install Python dependencies
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Create non-root user for security
RUN useradd -m -u 1001 botuser && chown -R botuser:botuser /app
USER botuser

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
  CMD python -c "import requests; requests.get('https://api.telegram.org', timeout=5)" || exit 1

# Run the bot
CMD ["python", "weather_bot.py"]
</file>

<file path="requirements.txt">
python-telegram-bot==20.7
requests==2.31.0
python-dotenv==1.0.0
</file>

<file path="weather_bot.py">
from dotenv import load_dotenv
load_dotenv()
import os
import requests
import logging
import json
import asyncio
from datetime import datetime, timedelta
from typing import Dict, List, Optional
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, filters, ContextTypes
from dataclasses import dataclass

# Load environment variables
load_dotenv()

# Enable logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Bot configuration
TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
WEATHER_API_KEY = os.getenv("WEATHER_API_KEY")

# Validate environment variables
if not TELEGRAM_BOT_TOKEN or not WEATHER_API_KEY:
    logger.error("Missing required environment variables!")
    logger.error("Please set TELEGRAM_BOT_TOKEN and WEATHER_API_KEY")
    exit(1)

# API URLs
WEATHER_API_URL = "https://api.openweathermap.org/data/2.5/weather"
FORECAST_API_URL = "https://api.openweathermap.org/data/2.5/forecast"
GEOCODING_API_URL = "https://api.openweathermap.org/geo/1.0/direct"

@dataclass
class UserPreferences:
    """User preferences data class"""
    unit: str = "metric"  # metric, imperial
    language: str = "en"
    favorites: List[str] = None
    default_city: str = None
    
    def __post_init__(self):
        if self.favorites is None:
            self.favorites = []

class WeatherBot:
    def __init__(self):
        self.application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
        self.user_preferences: Dict[int, UserPreferences] = {}
        self.setup_handlers()
        self.load_user_data()
    
    def setup_handlers(self):
        """Set up command and message handlers"""
        # Command handlers
        self.application.add_handler(CommandHandler("start", self.start_command))
        self.application.add_handler(CommandHandler("help", self.help_command))
        self.application.add_handler(CommandHandler("weather", self.weather_command))
        self.application.add_handler(CommandHandler("forecast", self.forecast_command))
        self.application.add_handler(CommandHandler("search", self.search_cities))
        self.application.add_handler(CommandHandler("favorites", self.favorites_command))
        self.application.add_handler(CommandHandler("addfav", self.add_favorite))
        self.application.add_handler(CommandHandler("removefav", self.remove_favorite))
        self.application.add_handler(CommandHandler("settings", self.settings_command))
        self.application.add_handler(CommandHandler("alerts", self.weather_alerts))
        self.application.add_handler(CommandHandler("compare", self.compare_cities))
        self.application.add_handler(CommandHandler("map", self.weather_map))
        
        # Callback query handler for inline keyboards
        self.application.add_handler(CallbackQueryHandler(self.handle_callback))
        
        # Message handler for city names
        self.application.add_handler(MessageHandler(
            filters.TEXT & ~filters.COMMAND, 
            self.handle_city_message
        ))
    
    def load_user_data(self):
        """Load user preferences from file"""
        try:
            if os.path.exists('user_preferences.json'):
                with open('user_preferences.json', 'r') as f:
                    data = json.load(f)
                    for user_id, prefs in data.items():
                        self.user_preferences[int(user_id)] = UserPreferences(**prefs)
        except Exception as e:
            logger.error(f"Error loading user data: {e}")
    
    def save_user_data(self):
        """Save user preferences to file"""
        try:
            data = {}
            for user_id, prefs in self.user_preferences.items():
                data[str(user_id)] = {
                    'unit': prefs.unit,
                    'language': prefs.language,
                    'favorites': prefs.favorites,
                    'default_city': prefs.default_city
                }
            with open('user_preferences.json', 'w') as f:
                json.dump(data, f, indent=2)
        except Exception as e:
            logger.error(f"Error saving user data: {e}")
    
    def get_user_prefs(self, user_id: int) -> UserPreferences:
        """Get user preferences or create default"""
        if user_id not in self.user_preferences:
            self.user_preferences[user_id] = UserPreferences()
        return self.user_preferences[user_id]
    
    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /start command"""
        keyboard = [
            [InlineKeyboardButton("ğŸŒ¤ï¸ Current Weather", callback_data="help_weather")],
            [InlineKeyboardButton("ğŸ“Š 5-Day Forecast", callback_data="help_forecast")],
            [InlineKeyboardButton("ğŸ” Search Cities", callback_data="help_search")],
            [InlineKeyboardButton("â­ Favorites", callback_data="help_favorites")],
            [InlineKeyboardButton("âš™ï¸ Settings", callback_data="help_settings")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        welcome_message = (
            "ğŸŒ¤ï¸ <b>Welcome to Advanced Weather Bot!</b> ğŸŒ¤ï¸\n\n"
            "I'm your comprehensive weather assistant with many features:\n\n"
            "ğŸ”¹ Current weather for any city\n"
            "ğŸ”¹ 5-day detailed forecasts\n"
            "ğŸ”¹ City search and suggestions\n"
            "ğŸ”¹ Favorite locations\n"
            "ğŸ”¹ Weather alerts\n"
            "ğŸ”¹ City comparisons\n"
            "ğŸ”¹ Customizable units & settings\n\n"
            "Choose a category below or type a city name to get started!"
        )
        await update.message.reply_text(welcome_message, parse_mode='HTML', reply_markup=reply_markup)
    
    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /help command"""
        help_message = (
            "ğŸ†˜ <b>Weather Bot Commands</b>\n\n"
            "ğŸ“ <b>Weather Commands:</b>\n"
            "â€¢ <code>/weather [city]</code> - Current weather\n"
            "â€¢ <code>/forecast [city]</code> - 5-day forecast\n"
            "â€¢ <code>/alerts [city]</code> - Weather alerts\n\n"
            "ğŸ” <b>Search & Discovery:</b>\n"
            "â€¢ <code>/search [query]</code> - Find cities\n"
            "â€¢ <code>/map [city]</code> - Weather map link\n"
            "â€¢ <code>/compare city1,city2</code> - Compare cities\n\n"
            "â­ <b>Favorites:</b>\n"
            "â€¢ <code>/favorites</code> - Show favorite cities\n"
            "â€¢ <code>/addfav [city]</code> - Add to favorites\n"
            "â€¢ <code>/removefav [city]</code> - Remove favorite\n\n"
            "âš™ï¸ <b>Settings:</b>\n"
            "â€¢ <code>/settings</code> - Change preferences\n\n"
            "ğŸ’¡ <b>Tips:</b>\n"
            "â€¢ Just type a city name for quick weather\n"
            "â€¢ Use quotes for cities with spaces: 'New York'\n"
            "â€¢ Set a default city in settings"
        )
        await update.message.reply_text(help_message, parse_mode='HTML')
    
    async def weather_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /weather command"""
        user_id = update.effective_user.id
        prefs = self.get_user_prefs(user_id)
        
        if not context.args:
            if prefs.default_city:
                city = prefs.default_city
            else:
                await update.message.reply_text(
                    "Please specify a city! Usage: <code>/weather [city]</code>\n"
                    "Example: <code>/weather London</code>\n"
                    "Or set a default city in /settings", parse_mode='HTML'
                )
                return
        else:
            city = " ".join(context.args)
        
        await self.get_and_send_weather(update, city, prefs)
    
    async def forecast_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /forecast command"""
        user_id = update.effective_user.id
        prefs = self.get_user_prefs(user_id)
        
        if not context.args:
            if prefs.default_city:
                city = prefs.default_city
            else:
                await update.message.reply_text(
                    "Please specify a city! Usage: <code>/forecast [city]</code>\n"
                    "Example: <code>/forecast Tokyo</code>", parse_mode='HTML'
                )
                return
        else:
            city = " ".join(context.args)
        
        await self.get_and_send_forecast(update, city, prefs)
    
    async def search_cities(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Search for cities"""
        if not context.args:
            await update.message.reply_text(
                "Please provide a search query! Usage: <code>/search [query]</code>\n"
                "Example: <code>/search paris</code>", parse_mode='HTML'
            )
            return
        
        query = " ".join(context.args)
        await self.search_and_show_cities(update, query)
    
    async def favorites_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Show favorite cities"""
        user_id = update.effective_user.id
        prefs = self.get_user_prefs(user_id)
        
        if not prefs.favorites:
            await update.message.reply_text(
                "You don't have any favorite cities yet!\n"
                "Add some using <code>/addfav [city]</code>", parse_mode='HTML'
            )
            return
        
        keyboard = []
        for city in prefs.favorites[:10]:  # Limit to 10 favorites
            keyboard.append([InlineKeyboardButton(f"ğŸŒ¤ï¸ {city}", callback_data=f"weather_{city}")])
        
        keyboard.append([InlineKeyboardButton("âš™ï¸ Manage Favorites", callback_data="manage_favorites")])
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        message = f"â­ <b>Your Favorite Cities ({len(prefs.favorites)})</b>\n\nClick on any city to get current weather:"
        await update.message.reply_text(message, parse_mode='HTML', reply_markup=reply_markup)
    
    async def add_favorite(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Add city to favorites"""
        if not context.args:
            await update.message.reply_text(
                "Please specify a city! Usage: <code>/addfav [city]</code>", parse_mode='HTML'
            )
            return
        
        city = " ".join(context.args)
        user_id = update.effective_user.id
        prefs = self.get_user_prefs(user_id)
        
        # Verify city exists
        if not await self.verify_city_exists(city):
            await update.message.reply_text(f"ğŸš« City '{city}' not found. Please check the spelling.")
            return
        
        if city.lower() not in [fav.lower() for fav in prefs.favorites]:
            prefs.favorites.append(city)
            self.save_user_data()
            await update.message.reply_text(f"â­ Added '{city}' to your favorites!")
        else:
            await update.message.reply_text(f"'{city}' is already in your favorites!")
    
    async def remove_favorite(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Remove city from favorites"""
        if not context.args:
            await update.message.reply_text(
                "Please specify a city! Usage: <code>/removefav [city]</code>", parse_mode='HTML'
            )
            return
        
        city = " ".join(context.args)
        user_id = update.effective_user.id
        prefs = self.get_user_prefs(user_id)
        
        # Find and remove city (case insensitive)
        for fav in prefs.favorites[:]:
            if fav.lower() == city.lower():
                prefs.favorites.remove(fav)
                self.save_user_data()
                await update.message.reply_text(f"ğŸ—‘ï¸ Removed '{fav}' from favorites!")
                return
        
        await update.message.reply_text(f"'{city}' is not in your favorites!")
    
    async def settings_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Show settings menu"""
        user_id = update.effective_user.id
        prefs = self.get_user_prefs(user_id)
        
        keyboard = [
            [InlineKeyboardButton(f"ğŸŒ¡ï¸ Units: {'Celsius' if prefs.unit == 'metric' else 'Fahrenheit'}", callback_data="toggle_units")],
            [InlineKeyboardButton(f"ğŸ  Default City: {prefs.default_city or 'None'}", callback_data="set_default_city")],
            [InlineKeyboardButton("â­ Manage Favorites", callback_data="manage_favorites")],
            [InlineKeyboardButton("ğŸ—‘ï¸ Reset All Settings", callback_data="reset_settings")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        message = (
            "âš™ï¸ <b>Settings</b>\n\n"
            f"ğŸŒ¡ï¸ Temperature Unit: {'Celsius (Â°C)' if prefs.unit == 'metric' else 'Fahrenheit (Â°F)'}\n"
            f"ğŸ  Default City: {prefs.default_city or 'Not set'}\n"
            f"â­ Favorite Cities: {len(prefs.favorites)}\n\n"
            "Click the buttons below to change settings:"
        )
        await update.message.reply_text(message, parse_mode='HTML', reply_markup=reply_markup)
    
    async def weather_alerts(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Show weather alerts for a city"""
        user_id = update.effective_user.id
        prefs = self.get_user_prefs(user_id)
        
        if not context.args:
            if prefs.default_city:
                city = prefs.default_city
            else:
                await update.message.reply_text(
                    "Please specify a city! Usage: <code>/alerts [city]</code>", parse_mode='HTML'
                )
                return
        else:
            city = " ".join(context.args)
        
        try:
            # Get weather data to check for alerts
            params = {
                'q': city,
                'appid': WEATHER_API_KEY,
                'units': prefs.unit
            }
            
            response = requests.get(WEATHER_API_URL, params=params, timeout=10)
            response.raise_for_status()
            data = response.json()
            
            alerts = []
            
            # Check for extreme conditions
            temp = data['main']['temp']
            humidity = data['main']['humidity']
            wind_speed = data.get('wind', {}).get('speed', 0)
            weather_id = data['weather'][0]['id']
            
            if prefs.unit == 'metric':
                if temp > 35:
                    alerts.append("ğŸ”¥ Extreme Heat Warning")
                elif temp < -10:
                    alerts.append("ğŸ§Š Extreme Cold Warning")
                if wind_speed > 10:
                    alerts.append("ğŸ’¨ High Wind Alert")
            else:
                if temp > 95:
                    alerts.append("ğŸ”¥ Extreme Heat Warning")
                elif temp < 14:
                    alerts.append("ğŸ§Š Extreme Cold Warning")
                if wind_speed > 22:
                    alerts.append("ğŸ’¨ High Wind Alert")
            
            if humidity > 85:
                alerts.append("ğŸ’§ High Humidity Alert")
            
            if weather_id < 300:
                alerts.append("â›ˆï¸ Thunderstorm Alert")
            elif weather_id < 600 and weather_id >= 500:
                alerts.append("ğŸŒ§ï¸ Heavy Rain Alert")
            elif weather_id < 700 and weather_id >= 600:
                alerts.append("â„ï¸ Snow Alert")
            
            city_name = f"{data['name']}, {data['sys']['country']}"
            
            if alerts:
                message = f"âš ï¸ <b>Weather Alerts for {city_name}</b>\n\n"
                message += "\n".join(f"â€¢ {alert}" for alert in alerts)
                message += f"\n\nğŸŒ¡ï¸ Current temp: {temp}Â°{'C' if prefs.unit == 'metric' else 'F'}"
            else:
                message = f"âœ… <b>No Weather Alerts for {city_name}</b>\n\nCurrent conditions are normal."
            
            await update.message.reply_text(message, parse_mode='HTML')
            
        except Exception as e:
            logger.error(f"Error getting alerts: {e}")
            await update.message.reply_text("âŒ Could not fetch weather alerts. Please try again later.")
    
    async def compare_cities(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Compare weather between cities"""
        if not context.args:
            await update.message.reply_text(
                "Please specify cities to compare!\n"
                "Usage: <code>/compare city1,city2</code>\n"
                "Example: <code>/compare London,Paris</code>", parse_mode='HTML'
            )
            return
        
        cities_input = " ".join(context.args)
        cities = [city.strip() for city in cities_input.split(',')]
        
        if len(cities) < 2:
            await update.message.reply_text(
                "Please specify at least 2 cities separated by commas!\n"
                "Example: <code>/compare London,Paris</code>", parse_mode='HTML'
            )
            return
        
        if len(cities) > 4:
            await update.message.reply_text("You can compare up to 4 cities at once!")
            cities = cities[:4]
        
        user_id = update.effective_user.id
        prefs = self.get_user_prefs(user_id)
        
        await self.compare_weather(update, cities, prefs)
    
    async def weather_map(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Provide weather map link"""
        if not context.args:
            await update.message.reply_text(
                "Please specify a city! Usage: <code>/map [city]</code>", parse_mode='HTML'
            )
            return
        
        city = " ".join(context.args)
        
        # Get city coordinates
        try:
            params = {
                'q': city,
                'appid': WEATHER_API_KEY,
                'limit': 1
            }
            
            response = requests.get(GEOCODING_API_URL, params=params, timeout=10)
            response.raise_for_status()
            data = response.json()
            
            if not data:
                await update.message.reply_text(f"ğŸš« City '{city}' not found.")
                return
            
            lat = data[0]['lat']
            lon = data[0]['lon']
            name = data[0]['name']
            country = data[0].get('country', '')
            
            # Create map links
            openweather_map = f"https://openweathermap.org/weathermap?basemap=map&cities=true&layer=temperature&lat={lat}&lon={lon}&zoom=10"
            google_maps = f"https://www.google.com/maps/@{lat},{lon},10z"
            
            keyboard = [
                [InlineKeyboardButton("ğŸ—ºï¸ OpenWeather Map", url=openweather_map)],
                [InlineKeyboardButton("ğŸ“ Google Maps", url=google_maps)]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            message = f"ğŸ—ºï¸ <b>Weather Maps for {name}, {country}</b>\n\nClick the links below to view interactive weather maps:"
            await update.message.reply_text(message, parse_mode='HTML', reply_markup=reply_markup)
            
        except Exception as e:
            logger.error(f"Error getting map: {e}")
            await update.message.reply_text("âŒ Could not generate map links. Please try again later.")
    
    async def handle_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle inline keyboard callbacks"""
        query = update.callback_query
        await query.answer()
        
        data = query.data
        user_id = update.effective_user.id
        prefs = self.get_user_prefs(user_id)
        
        if data.startswith("weather_"):
            city = data.replace("weather_", "")
            await self.get_and_send_weather(update, city, prefs, edit_message=True)
        
        elif data == "toggle_units":
            prefs.unit = "imperial" if prefs.unit == "metric" else "metric"
            self.save_user_data()
            await self.settings_command(update, context)
        
        elif data == "set_default_city":
            await query.edit_message_text(
                "ğŸ  To set a default city, use the command:\n"
                "<code>/addfav [city]</code> then come back to settings.\n\n"
                "Or just type a city name and I'll remember it!",
                parse_mode='HTML'
            )
        
        elif data == "manage_favorites":
            if not prefs.favorites:
                await query.edit_message_text(
                    "You don't have any favorite cities yet!\n"
                    "Add some using <code>/addfav [city]</code>",
                    parse_mode='HTML'
                )
                return
            
            keyboard = []
            for city in prefs.favorites:
                keyboard.append([InlineKeyboardButton(f"ğŸ—‘ï¸ Remove {city}", callback_data=f"removefav_{city}")])
            
            keyboard.append([InlineKeyboardButton("â¬…ï¸ Back to Settings", callback_data="back_to_settings")])
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await query.edit_message_text(
                "â­ <b>Manage Favorite Cities</b>\n\nClick to remove a city:",
                parse_mode='HTML',
                reply_markup=reply_markup
            )
        
        elif data.startswith("removefav_"):
            city = data.replace("removefav_", "")
            if city in prefs.favorites:
                prefs.favorites.remove(city)
                self.save_user_data()
            await self.handle_callback(update, context)  # Refresh the list
        
        elif data == "back_to_settings":
            await self.settings_command(update, context)
        
        elif data == "reset_settings":
            self.user_preferences[user_id] = UserPreferences()
            self.save_user_data()
            await query.edit_message_text("âœ… All settings have been reset to default!")
    
    async def handle_city_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle direct city name messages"""
        city = update.message.text.strip().strip('"\'')
        user_id = update.effective_user.id
        prefs = self.get_user_prefs(user_id)
        
        # Auto-add frequently searched cities to favorites
        if city.lower() not in [fav.lower() for fav in prefs.favorites] and len(prefs.favorites) < 5:
            if await self.verify_city_exists(city):
                keyboard = [[InlineKeyboardButton("â­ Add to Favorites", callback_data=f"addfav_{city}")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await self.get_and_send_weather(update, city, prefs, suggest_favorite=reply_markup)
            else:
                await self.get_and_send_weather(update, city, prefs)
        else:
            await self.get_and_send_weather(update, city, prefs)
    
    async def verify_city_exists(self, city: str) -> bool:
        """Verify if a city exists"""
        try:
            params = {
                'q': city,
                'appid': WEATHER_API_KEY,
                'units': 'metric'
            }
            response = requests.get(WEATHER_API_URL, params=params, timeout=5)
            return response.status_code == 200
        except:
            return False
    
    async def search_and_show_cities(self, update: Update, query: str):
        """Search for cities and show results"""
        try:
            await update.message.reply_chat_action(action="typing")
            
            params = {
                'q': query,
                'appid': WEATHER_API_KEY,
                'limit': 10
            }
            
            response = requests.get(GEOCODING_API_URL, params=params, timeout=10)
            response.raise_for_status()
            data = response.json()
            
            if not data:
                await update.message.reply_text(f"ğŸš« No cities found matching '{query}'")
                return
            
            keyboard = []
            message = f"ğŸ” <b>Cities matching '{query}':</b>\n\n"
            
            for i, city in enumerate(data[:8], 1):
                name = city['name']
                country = city.get('country', '')
                state = city.get('state', '')
                
                full_name = f"{name}, {country}"
                if state and state != name:
                    full_name = f"{name}, {state}, {country}"
                
                message += f"{i}. {full_name}\n"
                keyboard.append([InlineKeyboardButton(f"ğŸŒ¤ï¸ {full_name}", callback_data=f"weather_{name}")])
            
            reply_markup = InlineKeyboardMarkup(keyboard)
            await update.message.reply_text(message, parse_mode='HTML', reply_markup=reply_markup)
            
        except Exception as e:
            logger.error(f"Error searching cities: {e}")
            await update.message.reply_text("âŒ Could not search for cities. Please try again later.")
    
    async def get_and_send_weather(self, update: Update, city: str, prefs: UserPreferences, edit_message: bool = False, suggest_favorite=None):
        """Fetch weather data and send response"""
        try:
            if not edit_message:
                await update.message.reply_chat_action(action="typing")
            
            # Make API request
            params = {
                'q': city,
                'appid': WEATHER_API_KEY,
                'units': prefs.unit
            }
            
            response = requests.get(WEATHER_API_URL, params=params, timeout=10)
            
            if response.status_code == 404:
                message = f"ğŸš« City '{city}' not found. Please check the spelling and try again."
                if edit_message:
                    await update.callback_query.edit_message_text(message)
                else:
                    await update.message.reply_text(message)
                return
            
            response.raise_for_status()
            data = response.json()
            
            # Format weather information
            weather_message = self.format_weather_message(data, prefs)
            
            if edit_message:
                await update.callback_query.edit_message_text(weather_message, parse_mode='HTML')
            else:
                await update.message.reply_text(weather_message, parse_mode='HTML', reply_markup=suggest_favorite)
            
        except requests.exceptions.Timeout:
            message = "â° Request timeout. Please try again later."
            if edit_message:
                await update.callback_query.edit_message_text(message)
            else:
                await update.message.reply_text(message)
        except requests.exceptions.RequestException as e:
            logger.error(f"API request failed: {e}")
            message = "âŒ Sorry, I couldn't fetch weather data right now. Please try again later."
            if edit_message:
                await update.callback_query.edit_message_text(message)
            else:
                await update.message.reply_text(message)
        except Exception as e:
            logger.error(f"Unexpected error: {e}")
            message = "âŒ An unexpected error occurred. Please try again."
            if edit_message:
                await update.callback_query.edit_message_text(message)
            else:
                await update.message.reply_text(message)
    
    async def get_and_send_forecast(self, update: Update, city: str, prefs: UserPreferences):
        """Fetch and send 5-day weather forecast"""
        try:
            await update.message.reply_chat_action(action="typing")
            
            params = {
                'q': city,
                'appid': WEATHER_API_KEY,
                'units': prefs.unit
            }
            
            response = requests.get(FORECAST_API_URL, params=params, timeout=10)
            
            if response.status_code == 404:
                await update.message.reply_text(f"ğŸš« City '{city}' not found.")
                return
            
            response.raise_for_status()
            data = response.json()
            
            forecast_message = self.format_forecast_message(data, prefs)
            await update.message.reply_text(forecast_message, parse_mode='HTML')
            
        except Exception as e:
            logger.error(f"Error getting forecast: {e}")
            await update.message.reply_text("âŒ Could not fetch forecast data. Please try again later.")
    
    async def compare_weather(self, update: Update, cities: List[str], prefs: UserPreferences):
        """Compare weather between multiple cities"""
        try:
            await update.message.reply_chat_action(action="typing")
            
            weather_data = []
            
            for city in cities:
                params = {
                    'q': city,
                    'appid': WEATHER_API_KEY,
                    'units': prefs.unit
                }
                
                response = requests.get(WEATHER_API_URL, params=params, timeout=10)
                if response.status_code == 200:
                    weather_data.append(response.json())
                else:
                    await update.message.reply_text(f"ğŸš« City '{city}' not found.")
                    return
            
            if not weather_data:
                await update.message.reply_text("âŒ Could not fetch data for any cities.")
                return
            
            # Format comparison message
            unit_symbol = "Â°C" if prefs.unit == "metric" else "Â°F"
            speed_unit = "m/s" if prefs.unit == "metric" else "mph"
            
            message = "ğŸ† <b>Weather Comparison</b>\n\n"
            
            # Temperature comparison
            temps = [(data['name'], data['main']['temp']) for data in weather_data]
            temps.sort(key=lambda x: x[1], reverse=True)
            
            message += f"ğŸŒ¡ï¸ <b>Temperature ({unit_symbol})</b>\n"
            for i, (name, temp) in enumerate(temps, 1):
                emoji = "ğŸ”¥" if i == 1 else "ğŸ§Š" if i == len(temps) else "ğŸŒ¡ï¸"
                message += f"{i}. {emoji} {name}: {temp:.1f}{unit_symbol}\n"
            
            message += "\n"
            
            # Humidity comparison
            humidities = [(data['name'], data['main']['humidity']) for data in weather_data]
            humidities.sort(key=lambda x: x[1], reverse=True)
            
            message += "ğŸ’§ <b>Humidity (%)</b>\n"
            for i, (name, humidity) in enumerate(humidities, 1):
                emoji = "ğŸ’§" if i == 1 else "ğŸœï¸" if i == len(humidities) else "ğŸ’¨"
                message += f"{i}. {emoji} {name}: {humidity}%\n"
            
            message += "\n"
            
            # Weather conditions
            message += "â˜ï¸ <b>Current Conditions</b>\n"
            for data in weather_data:
                name = data['name']
                condition = data['weather'][0]['description'].title()
                emoji = self.get_weather_emoji(data['weather'][0]['id'])
                message += f"{emoji} {name}: {condition}\n"
            
            # Find extremes
            message += "\nğŸ… <b>Highlights</b>\n"
            hottest = max(weather_data, key=lambda x: x['main']['temp'])
            coldest = min(weather_data, key=lambda x: x['main']['temp'])
            most_humid = max(weather_data, key=lambda x: x['main']['humidity'])
            
            message += f"ğŸ”¥ Hottest: {hottest['name']} ({hottest['main']['temp']:.1f}{unit_symbol})\n"
            message += f"ğŸ§Š Coldest: {coldest['name']} ({coldest['main']['temp']:.1f}{unit_symbol})\n"
            message += f"ğŸ’§ Most Humid: {most_humid['name']} ({most_humid['main']['humidity']}%)"
            
            await update.message.reply_text(message, parse_mode='HTML')
            
        except Exception as e:
            logger.error(f"Error comparing weather: {e}")
            await update.message.reply_text("âŒ Could not compare weather data. Please try again later.")
    
    def format_weather_message(self, data, prefs: UserPreferences):
        """Format weather data into a nice message"""
        city = data['name']
        country = data['sys']['country']
        temp = data['main']['temp']
        feels_like = data['main']['feels_like']
        humidity = data['main']['humidity']
        pressure = data['main']['pressure']
        description = data['weather'][0]['description'].title()
        
        # Get additional data
        wind_speed = data.get('wind', {}).get('speed', 0)
        wind_deg = data.get('wind', {}).get('deg', 0)
        visibility = data.get('visibility', 0) / 1000 if data.get('visibility') else None
        clouds = data.get('clouds', {}).get('all', 0)
        
        # Sunrise/sunset
        sunrise = datetime.fromtimestamp(data['sys']['sunrise']).strftime('%H:%M')
        sunset = datetime.fromtimestamp(data['sys']['sunset']).strftime('%H:%M')
        
        # Get weather emoji
        weather_id = data['weather'][0]['id']
        emoji = self.get_weather_emoji(weather_id)
        
        # Format units
        if prefs.unit == 'metric':
            temp_unit = "Â°C"
            speed_unit = "m/s"
            temp = round(temp)
            feels_like = round(feels_like)
        else:
            temp_unit = "Â°F"
            speed_unit = "mph"
            temp = round(temp)
            feels_like = round(feels_like)
        
        # Wind direction
        wind_directions = ["N", "NNE", "NE", "ENE", "E", "ESE", "SE", "SSE",
                          "S", "SSW", "SW", "WSW", "W", "WNW", "NW", "NNW"]
        wind_dir = wind_directions[round(wind_deg / 22.5) % 16] if wind_deg else "N"
        
        message = (
            f"{emoji} <b>Weather in {city}, {country}</b>\n\n"
            f"ğŸŒ¡ï¸ Temperature: {temp}{temp_unit}\n"
            f"ğŸ¤” Feels like: {feels_like}{temp_unit}\n"
            f"ğŸ’§ Humidity: {humidity}%\n"
            f"ğŸ“Š Pressure: {pressure} hPa\n"
            f"ğŸ’¨ Wind: {wind_speed:.1f} {speed_unit} {wind_dir}\n"
            f"â˜ï¸ Cloudiness: {clouds}%\n"
        )
        
        if visibility:
            message += f"ğŸ‘ï¸ Visibility: {visibility:.1f} km\n"
        
        message += (
            f"ğŸ“ Conditions: {description}\n\n"
            f"ğŸŒ… Sunrise: {sunrise}\n"
            f"ğŸŒ‡ Sunset: {sunset}"
        )
        
        return message
    
    def format_forecast_message(self, data, prefs: UserPreferences):
        """Format 5-day forecast data"""
        city = data['city']['name']
        country = data['city']['country']
        
        unit_symbol = "Â°C" if prefs.unit == "metric" else "Â°F"
        
        message = f"ğŸ“Š <b>5-Day Forecast for {city}, {country}</b>\n\n"
        
        # Group forecasts by day
        daily_forecasts = {}
        for item in data['list']:
            date = datetime.fromtimestamp(item['dt']).date()
            if date not in daily_forecasts:
                daily_forecasts[date] = []
            daily_forecasts[date].append(item)
        
        # Process up to 5 days
        for i, (date, forecasts) in enumerate(list(daily_forecasts.items())[:5]):
            day_name = date.strftime('%A')
            date_str = date.strftime('%m/%d')
            
            # Get min/max temperatures for the day
            temps = [f['main']['temp'] for f in forecasts]
            min_temp = min(temps)
            max_temp = max(temps)
            
            # Get most common weather condition
            conditions = [f['weather'][0] for f in forecasts]
            main_condition = max(set(c['main'] for c in conditions), 
                               key=[c['main'] for c in conditions].count)
            
            # Find representative weather ID for emoji
            weather_ids = [c['id'] for c in conditions if c['main'] == main_condition]
            representative_id = weather_ids[0] if weather_ids else conditions[0]['id']
            
            emoji = self.get_weather_emoji(representative_id)
            
            # Get precipitation probability if available
            pop = max([f.get('pop', 0) for f in forecasts]) * 100
            
            message += f"{emoji} <b>{day_name} ({date_str})</b>\n"
            message += f"   ğŸŒ¡ï¸ {min_temp:.0f}{unit_symbol} - {max_temp:.0f}{unit_symbol}"
            
            if pop > 20:
                message += f" | ğŸŒ§ï¸ {pop:.0f}%"
            
            message += f"\n   ğŸ“ {main_condition}\n\n"
        
        return message
    
    def get_weather_emoji(self, weather_id):
        """Get appropriate emoji for weather condition"""
        if weather_id < 300:
            return "â›ˆï¸"  # Thunderstorm
        elif weather_id < 400:
            return "ğŸŒ¦ï¸"  # Drizzle
        elif weather_id < 600:
            return "ğŸŒ§ï¸"  # Rain
        elif weather_id < 700:
            return "â„ï¸"  # Snow
        elif weather_id < 800:
            return "ğŸŒ«ï¸"  # Atmosphere (fog, mist, etc.)
        elif weather_id == 800:
            return "â˜€ï¸"  # Clear sky
        else:
            return "â˜ï¸"  # Clouds
    
    def run(self):
        """Start the bot"""
        print("ğŸš€ Starting Enhanced Weather Bot...")
        print(f"ğŸ“Š Loaded preferences for {len(self.user_preferences)} users")
        self.application.run_polling()

# Error handler
async def error_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle errors"""
    logger.warning(f'Update "{update}" caused error "{context.error}"')

if __name__ == '__main__':
    try:
        # Create and run the bot
        bot = WeatherBot()
        bot.application.add_error_handler(error_handler)
        bot.run()
    except KeyboardInterrupt:
        print("\nğŸ›‘ Bot stopped by user")
    except Exception as e:
        logger.error(f"Failed to start bot: {e}")
        print(f"âŒ Error: {e}")
</file>

</files>
